import{r as Eo}from"./ClfaVKLN.js";import ga from"./SCME8O5H.js";var sn=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ut(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}function So(i){if(Object.prototype.hasOwnProperty.call(i,"__esModule"))return i;var e=i.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(i).forEach(function(r){var n=Object.getOwnPropertyDescriptor(i,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return i[r]}})}),t}var qr,on;function Ro(){if(on)return qr;on=1,qr=i;function i(e){var t,r;if(typeof e!="function")throw new Error("expected a function but got "+e);return function(){return t||(t=!0,r=e.apply(this,arguments)),r}}return qr}var Zr={},cn;function To(){return cn||(cn=1,function(i){function e(v,k){var S;return v instanceof Buffer?S=v:S=Buffer.from(v.buffer,v.byteOffset,v.byteLength),S.toString(k)}var t=function(v){return Buffer.from(v)};function r(v){for(var k=0,S=Math.min(256*256,v.length+1),O=new Uint16Array(S),I=[],A=0;;){var x=k<v.length;if(!x||A>=S-1){var R=O.subarray(0,A),D=R;if(I.push(String.fromCharCode.apply(null,D)),!x)return I.join("");v=v.subarray(k),k=0,A=0}var j=v[k++];if((j&128)===0)O[A++]=j;else if((j&224)===192){var H=v[k++]&63;O[A++]=(j&31)<<6|H}else if((j&240)===224){var H=v[k++]&63,L=v[k++]&63;O[A++]=(j&31)<<12|H<<6|L}else if((j&248)===240){var H=v[k++]&63,L=v[k++]&63,F=v[k++]&63,K=(j&7)<<18|H<<12|L<<6|F;K>65535&&(K-=65536,O[A++]=K>>>10&1023|55296,K=56320|K&1023),O[A++]=K}}}function n(v){for(var k=0,S=v.length,O=0,I=Math.max(32,S+(S>>>1)+7),A=new Uint8Array(I>>>3<<3);k<S;){var x=v.charCodeAt(k++);if(x>=55296&&x<=56319){if(k<S){var R=v.charCodeAt(k);(R&64512)===56320&&(++k,x=((x&1023)<<10)+(R&1023)+65536)}if(x>=55296&&x<=56319)continue}if(O+4>A.length){I+=8,I*=1+k/v.length*2,I=I>>>3<<3;var D=new Uint8Array(I);D.set(A),A=D}if((x&4294967168)===0){A[O++]=x;continue}else if((x&4294965248)===0)A[O++]=x>>>6&31|192;else if((x&4294901760)===0)A[O++]=x>>>12&15|224,A[O++]=x>>>6&63|128;else if((x&4292870144)===0)A[O++]=x>>>18&7|240,A[O++]=x>>>12&63|128,A[O++]=x>>>6&63|128;else continue;A[O++]=x&63|128}return A.slice?A.slice(0,O):A.subarray(0,O)}var a="Failed to ",s=function(v,k,S){if(v)throw new Error("".concat(a).concat(k,": the '").concat(S,"' option is unsupported."))},o=typeof Buffer=="function"&&Buffer.from,c=o?t:n;function u(){this.encoding="utf-8"}u.prototype.encode=function(v,k){return s(k&&k.stream,"encode","stream"),c(v)};function f(v){var k;try{var S=new Blob([v],{type:"text/plain;charset=UTF-8"});k=URL.createObjectURL(S);var O=new XMLHttpRequest;return O.open("GET",k,!1),O.send(),O.responseText}finally{k&&URL.revokeObjectURL(k)}}var d=!o&&typeof Blob=="function"&&typeof URL=="function"&&typeof URL.createObjectURL=="function",h=["utf-8","utf8","unicode-1-1-utf-8"],w=r;o?w=e:d&&(w=function(v){try{return f(v)}catch{return r(v)}});var _="construct 'TextDecoder'",y="".concat(a," ").concat(_,": the ");function b(v,k){s(k&&k.fatal,_,"fatal"),v=v||"utf-8";var S;if(o?S=Buffer.isEncoding(v):S=h.indexOf(v.toLowerCase())!==-1,!S)throw new RangeError("".concat(y," encoding label provided ('").concat(v,"') is invalid."));this.encoding=v,this.fatal=!1,this.ignoreBOM=!1}b.prototype.decode=function(v,k){s(k&&k.stream,"decode","stream");var S;return v instanceof Uint8Array?S=v:v.buffer instanceof ArrayBuffer?S=new Uint8Array(v.buffer):S=new Uint8Array(v),w(S,this.encoding)},i.TextEncoder=i.TextEncoder||u,i.TextDecoder=i.TextDecoder||b}(typeof window<"u"?window:typeof sn<"u"?sn:Zr)),Zr}var Gr,fn;function $o(){return fn||(fn=1,To(),Gr={encode:i=>new TextEncoder().encode(i),decode:i=>new TextDecoder().decode(i)}),Gr}var Wr,ln;function Ao(){if(ln)return Wr;ln=1,Wr=i;function i(e,t,r){var n;return function(){if(!t)return e.apply(this,arguments);var a=this,s=arguments,o=r&&!n;if(clearTimeout(n),n=setTimeout(function(){if(n=null,!o)return e.apply(a,s)},t),o)return e.apply(this,arguments)}}return Wr}var Xr,un;function Zi(){if(un)return Xr;un=1;function i(o){if(o.length===0)return".";let c=r(o);return c=c.reduce(s,[]),t(...c)}function e(...o){let c="";for(let u of o)u.startsWith("/")?c=u:c=i(t(c,u));return c}function t(...o){if(o.length===0)return"";let c=o.join("/");return c=c.replace(/\/{2,}/g,"/"),c}function r(o){if(o.length===0)return[];if(o==="/")return["/"];let c=o.split("/");return c[c.length-1]===""&&c.pop(),o[0]==="/"?c[0]="/":c[0]!=="."&&c.unshift("."),c}function n(o){const c=o.lastIndexOf("/");if(c===-1)throw new Error(`Cannot get dirname of "${o}"`);return c===0?"/":o.slice(0,c)}function a(o){if(o==="/")throw new Error(`Cannot get basename of "${o}"`);const c=o.lastIndexOf("/");return c===-1?o:o.slice(c+1)}function s(o,c){if(o.length===0)return o.push(c),o;if(c===".")return o;if(c===".."){if(o.length===1){if(o[0]==="/")throw new Error("Unable to normalize path - traverses above root directory");if(o[0]===".")return o.push(c),o}return o[o.length-1]===".."?(o.push(".."),o):(o.pop(),o)}return o.push(c),o}return Xr={join:t,normalize:i,split:r,basename:a,dirname:n,resolve:e},Xr}var Kr,hn;function va(){if(hn)return Kr;hn=1;function i(s){return class extends Error{constructor(...o){super(...o),this.code=s,this.message?this.message=s+": "+this.message:this.message=s}}}const e=i("EEXIST"),t=i("ENOENT"),r=i("ENOTDIR"),n=i("ENOTEMPTY"),a=i("ETIMEDOUT");return Kr={EEXIST:e,ENOENT:t,ENOTDIR:r,ENOTEMPTY:n,ETIMEDOUT:a},Kr}var Yr,dn;function Oo(){if(dn)return Yr;dn=1;const i=Zi(),{EEXIST:e,ENOENT:t,ENOTDIR:r,ENOTEMPTY:n}=va(),a=0;return Yr=class{constructor(){}_makeRoot(o=new Map){return o.set(a,{mode:511,type:"dir",size:0,ino:0,mtimeMs:Date.now()}),o}activate(o=null){o===null?this._root=new Map([["/",this._makeRoot()]]):typeof o=="string"?this._root=new Map([["/",this._makeRoot(this.parse(o))]]):this._root=o}get activated(){return!!this._root}deactivate(){this._root=void 0}size(){return this._countInodes(this._root.get("/"))-1}_countInodes(o){let c=1;for(let[u,f]of o)u!==a&&(c+=this._countInodes(f));return c}autoinc(){return this._maxInode(this._root.get("/"))+1}_maxInode(o){let c=o.get(a).ino;for(let[u,f]of o)u!==a&&(c=Math.max(c,this._maxInode(f)));return c}print(o=this._root.get("/")){let c="";const u=(f,d)=>{for(let[h,w]of f){if(h===0)continue;let _=w.get(a),y=_.mode.toString(8);c+=`${"	".repeat(d)}${h}	${y}`,_.type==="file"?c+=`	${_.size}	${_.mtimeMs}
`:(c+=`
`,u(w,d+1))}};return u(o,0),c}parse(o){let c=0;function u(w){const _=++c,y=w.length===1?"dir":"file";let[b,v,k]=w;return b=parseInt(b,8),v=v?parseInt(v):0,k=k?parseInt(k):Date.now(),new Map([[a,{mode:b,type:y,size:v,mtimeMs:k,ino:_}]])}let f=o.trim().split(`
`),d=this._makeRoot(),h=[{indent:-1,node:d},{indent:0,node:null}];for(let w of f){let y=w.match(/^\t*/)[0].length;w=w.slice(y);let[b,...v]=w.split("	"),k=u(v);if(y<=h[h.length-1].indent)for(;y<=h[h.length-1].indent;)h.pop();h.push({indent:y,node:k}),h[h.length-2].node.set(b,k)}return d}_lookup(o,c=!0){let u=this._root,f="/",d=i.split(o);for(let h=0;h<d.length;++h){let w=d[h];if(u=u.get(w),!u)throw new t(o);if(c||h<d.length-1){const _=u.get(a);if(_.type==="symlink"){let y=i.resolve(f,_.target);u=this._lookup(y)}f?f=i.join(f,w):f=w}}return u}mkdir(o,{mode:c}){if(o==="/")throw new e;let u=this._lookup(i.dirname(o)),f=i.basename(o);if(u.has(f))throw new e;let d=new Map,h={mode:c,type:"dir",size:0,mtimeMs:Date.now(),ino:this.autoinc()};d.set(a,h),u.set(f,d)}rmdir(o){let c=this._lookup(o);if(c.get(a).type!=="dir")throw new r;if(c.size>1)throw new n;let u=this._lookup(i.dirname(o)),f=i.basename(o);u.delete(f)}readdir(o){let c=this._lookup(o);if(c.get(a).type!=="dir")throw new r;return[...c.keys()].filter(u=>typeof u=="string")}writeStat(o,c,{mode:u}){let f;try{let y=this.stat(o);u==null&&(u=y.mode),f=y.ino}catch{}u==null&&(u=438),f==null&&(f=this.autoinc());let d=this._lookup(i.dirname(o)),h=i.basename(o),w={mode:u,type:"file",size:c,mtimeMs:Date.now(),ino:f},_=new Map;return _.set(a,w),d.set(h,_),w}unlink(o){let c=this._lookup(i.dirname(o)),u=i.basename(o);c.delete(u)}rename(o,c){let u=i.basename(c),f=this._lookup(o);this._lookup(i.dirname(c)).set(u,f),this.unlink(o)}stat(o){return this._lookup(o).get(a)}lstat(o){return this._lookup(o,!1).get(a)}readlink(o){return this._lookup(o,!1).get(a).target}symlink(o,c){let u,f;try{let y=this.stat(c);f===null&&(f=y.mode),u=y.ino}catch{}f==null&&(f=40960),u==null&&(u=this.autoinc());let d=this._lookup(i.dirname(c)),h=i.basename(c),w={mode:f,type:"symlink",target:o,size:0,mtimeMs:Date.now(),ino:u},_=new Map;return _.set(a,w),d.set(h,_),w}_du(o){let c=0;for(const[u,f]of o.entries())u===a?c+=f.size:c+=this._du(f);return c}du(o){let c=this._lookup(o);return this._du(c)}},Yr}class ba{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbName=e,this._storeName=t,this._init()}_init(){this._dbp||(this._dbp=new Promise((e,t)=>{const r=indexedDB.open(this._dbName);r.onerror=()=>t(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=()=>{r.result.createObjectStore(this._storeName)}}))}_withIDBStore(e,t){return this._init(),this._dbp.then(r=>new Promise((n,a)=>{const s=r.transaction(this.storeName,e);s.oncomplete=()=>n(),s.onabort=s.onerror=()=>a(s.error),t(s.objectStore(this.storeName))}))}_close(){return this._init(),this._dbp.then(e=>{e.close(),this._dbp=void 0})}}let Vr;function $t(){return Vr||(Vr=new ba),Vr}function Io(i,e=$t()){let t;return e._withIDBStore("readwrite",r=>{t=r.get(i)}).then(()=>t.result)}function jo(i,e,t=$t()){return t._withIDBStore("readwrite",r=>{r.put(e,i)})}function Bo(i,e,t=$t()){return t._withIDBStore("readwrite",r=>{const n=r.get(i);n.onsuccess=()=>{r.put(e(n.result),i)}})}function Co(i,e=$t()){return e._withIDBStore("readwrite",t=>{t.delete(i)})}function Do(i=$t()){return i._withIDBStore("readwrite",e=>{e.clear()})}function Po(i=$t()){const e=[];return i._withIDBStore("readwrite",t=>{(t.openKeyCursor||t.openCursor).call(t).onsuccess=function(){this.result&&(e.push(this.result.key),this.result.continue())}}).then(()=>e)}function No(i=$t()){return i._close()}const zo=Object.freeze(Object.defineProperty({__proto__:null,Store:ba,clear:Do,close:No,del:Co,get:Io,keys:Po,set:jo,update:Bo},Symbol.toStringTag,{value:"Module"})),ya=So(zo);var Jr,wn;function Mo(){if(wn)return Jr;wn=1;const i=ya;return Jr=class{constructor(t,r){this._database=t,this._storename=r,this._store=new i.Store(this._database,this._storename)}saveSuperblock(t){return i.set("!root",t,this._store)}loadSuperblock(){return i.get("!root",this._store)}readFile(t){return i.get(t,this._store)}writeFile(t,r){return i.set(t,r,this._store)}unlink(t){return i.del(t,this._store)}wipe(){return i.clear(this._store)}close(){return i.close(this._store)}},Jr}var Qr,mn;function Fo(){return mn||(mn=1,Qr=class{constructor(e){this._url=e}loadSuperblock(){return fetch(this._url+"/.superblock.txt").then(e=>e.ok?e.text():null)}async readFile(e){const t=await fetch(this._url+e);if(t.status===200)return t.arrayBuffer();throw new Error("ENOENT")}async sizeFile(e){const t=await fetch(this._url+e,{method:"HEAD"});if(t.status===200)return t.headers.get("content-length");throw new Error("ENOENT")}}),Qr}var ei,pn;function Uo(){if(pn)return ei;pn=1;const i=ya,e=t=>new Promise(r=>setTimeout(r,t));return ei=class{constructor(r,n){this._id=Math.random(),this._database=r,this._storename=n,this._store=new i.Store(this._database,this._storename),this._lock=null}async has({margin:r=2e3}={}){if(this._lock&&this._lock.holder===this._id){const n=Date.now();return this._lock.expires>n+r?!0:await this.renew()}else return!1}async renew({ttl:r=5e3}={}){let n;return await i.update("lock",a=>{const o=Date.now()+r;return n=a&&a.holder===this._id,this._lock=n?{holder:this._id,expires:o}:a,this._lock},this._store),n}async acquire({ttl:r=5e3}={}){let n,a,s;if(await i.update("lock",o=>{const c=Date.now(),u=c+r;return a=o&&o.expires<c,n=o===void 0||a,s=o&&o.holder===this._id,this._lock=n?{holder:this._id,expires:u}:o,this._lock},this._store),s)throw new Error("Mutex double-locked");return n}async wait({interval:r=100,limit:n=6e3,ttl:a}={}){for(;n--;){if(await this.acquire({ttl:a}))return!0;await e(r)}throw new Error("Mutex timeout")}async release({force:r=!1}={}){let n,a,s;if(await i.update("lock",o=>(n=r||o&&o.holder===this._id,a=o===void 0,s=o&&o.holder!==this._id,this._lock=n?void 0:o,this._lock),this._store),await i.close(this._store),!n&&!r){if(a)throw new Error("Mutex double-freed");if(s)throw new Error("Mutex lost ownership")}return n}},ei}var ti,_n;function Lo(){return _n||(_n=1,ti=class{constructor(e){this._id=Math.random(),this._database=e,this._has=!1,this._release=null}async has(){return this._has}async acquire(){return new Promise(e=>{navigator.locks.request(this._database+"_lock",{ifAvailable:!0},t=>(this._has=!!t,e(!!t),new Promise(r=>{this._release=r})))})}async wait({timeout:e=6e5}={}){return new Promise((t,r)=>{const n=new AbortController;setTimeout(()=>{n.abort(),r(new Error("Mutex timeout"))},e),navigator.locks.request(this._database+"_lock",{signal:n.signal},a=>(this._has=!!a,t(!!a),new Promise(s=>{this._release=s})))})}async release({force:e=!1}={}){this._has=!1,this._release?this._release():e&&navigator.locks.request(this._database+"_lock",{steal:!0},t=>!0)}}),ti}var ri,gn;function Ho(){if(gn)return ri;gn=1;const{encode:i,decode:e}=$o(),t=Ao(),r=Oo(),{ENOENT:n,ENOTEMPTY:a,ETIMEDOUT:s}=va(),o=Mo(),c=Fo(),u=Uo(),f=Lo(),d=Zi();return ri=class{constructor(){this.saveSuperblock=t(()=>{this.flush()},500)}async init(w,{wipe:_,url:y,urlauto:b,fileDbName:v=w,db:k=null,fileStoreName:S=w+"_files",lockDbName:O=w+"_lock",lockStoreName:I=w+"_lock"}={}){this._name=w,this._idb=k||new o(v,S),this._mutex=navigator.locks?new f(w):new u(O,I),this._cache=new r(w),this._opts={wipe:_,url:y},this._needsWipe=!!_,y&&(this._http=new c(y),this._urlauto=!!b)}async activate(){if(this._cache.activated)return;this._needsWipe&&(this._needsWipe=!1,await this._idb.wipe(),await this._mutex.release({force:!0})),await this._mutex.has()||await this._mutex.wait();const w=await this._idb.loadSuperblock();if(w)this._cache.activate(w);else if(this._http){const _=await this._http.loadSuperblock();this._cache.activate(_),await this._saveSuperblock()}else this._cache.activate();if(!await this._mutex.has())throw new s}async deactivate(){await this._mutex.has()&&await this._saveSuperblock(),this._cache.deactivate();try{await this._mutex.release()}catch(w){console.log(w)}await this._idb.close()}async _saveSuperblock(){this._cache.activated&&(this._lastSavedAt=Date.now(),await this._idb.saveSuperblock(this._cache._root))}_writeStat(w,_,y){let b=d.split(d.dirname(w)),v=b.shift();for(let k of b){v=d.join(v,k);try{this._cache.mkdir(v,{mode:511})}catch{}}return this._cache.writeStat(w,_,y)}async readFile(w,_){const{encoding:y}=_;if(y&&y!=="utf8")throw new Error('Only "utf8" encoding is supported in readFile');let b=null,v=null;try{v=this._cache.stat(w),b=await this._idb.readFile(v.ino)}catch(k){if(!this._urlauto)throw k}if(!b&&this._http){let k=this._cache.lstat(w);for(;k.type==="symlink";)w=d.resolve(d.dirname(w),k.target),k=this._cache.lstat(w);b=await this._http.readFile(w)}if(b&&((!v||v.size!=b.byteLength)&&(v=await this._writeStat(w,b.byteLength,{mode:v?v.mode:438}),this.saveSuperblock()),y==="utf8"?b=e(b):b.toString=()=>e(b)),!v)throw new n(w);return b}async writeFile(w,_,y){const{mode:b,encoding:v="utf8"}=y;if(typeof _=="string"){if(v!=="utf8")throw new Error('Only "utf8" encoding is supported in writeFile');_=i(_)}const k=await this._cache.writeStat(w,_.byteLength,{mode:b});await this._idb.writeFile(k.ino,_)}async unlink(w,_){const y=this._cache.lstat(w);this._cache.unlink(w),y.type!=="symlink"&&await this._idb.unlink(y.ino)}readdir(w,_){return this._cache.readdir(w)}mkdir(w,_){const{mode:y=511}=_;this._cache.mkdir(w,{mode:y})}rmdir(w,_){if(w==="/")throw new a;this._cache.rmdir(w)}rename(w,_){this._cache.rename(w,_)}stat(w,_){return this._cache.stat(w)}lstat(w,_){return this._cache.lstat(w)}readlink(w,_){return this._cache.readlink(w)}symlink(w,_){this._cache.symlink(w,_)}async backFile(w,_){let y=await this._http.sizeFile(w);await this._writeStat(w,y,_)}du(w){return this._cache.du(w)}flush(){return this._saveSuperblock()}},ri}var ii,vn;function qo(){return vn||(vn=1,ii=class{constructor(e){this.type=e.type,this.mode=e.mode,this.size=e.size,this.ino=e.ino,this.mtimeMs=e.mtimeMs,this.ctimeMs=e.ctimeMs||e.mtimeMs,this.uid=1,this.gid=1,this.dev=1}isFile(){return this.type==="file"}isDirectory(){return this.type==="dir"}isSymbolicLink(){return this.type==="symlink"}}),ii}var ni,bn;function Zo(){if(bn)return ni;bn=1;const i=Ho(),e=qo(),t=Zi();function r(s,o,...c){return s=t.normalize(s),(typeof o>"u"||typeof o=="function")&&(o={}),typeof o=="string"&&(o={encoding:o}),[s,o,...c]}function n(s,o,c,...u){return s=t.normalize(s),(typeof c>"u"||typeof c=="function")&&(c={}),typeof c=="string"&&(c={encoding:c}),[s,o,c,...u]}function a(s,o,...c){return[t.normalize(s),t.normalize(o),...c]}return ni=class{constructor(o,c={}){this.init=this.init.bind(this),this.readFile=this._wrap(this.readFile,r,!1),this.writeFile=this._wrap(this.writeFile,n,!0),this.unlink=this._wrap(this.unlink,r,!0),this.readdir=this._wrap(this.readdir,r,!1),this.mkdir=this._wrap(this.mkdir,r,!0),this.rmdir=this._wrap(this.rmdir,r,!0),this.rename=this._wrap(this.rename,a,!0),this.stat=this._wrap(this.stat,r,!1),this.lstat=this._wrap(this.lstat,r,!1),this.readlink=this._wrap(this.readlink,r,!1),this.symlink=this._wrap(this.symlink,a,!0),this.backFile=this._wrap(this.backFile,r,!0),this.du=this._wrap(this.du,r,!1),this._deactivationPromise=null,this._deactivationTimeout=null,this._activationPromise=null,this._operations=new Set,o&&this.init(o,c)}async init(...o){return this._initPromiseResolve&&await this._initPromise,this._initPromise=this._init(...o),this._initPromise}async _init(o,c={}){await this._gracefulShutdown(),this._activationPromise&&await this._deactivate(),this._backend&&this._backend.destroy&&await this._backend.destroy(),this._backend=c.backend||new i,this._backend.init&&await this._backend.init(o,c),this._initPromiseResolve&&(this._initPromiseResolve(),this._initPromiseResolve=null),c.defer||this.stat("/")}async _gracefulShutdown(){this._operations.size>0&&(this._isShuttingDown=!0,await new Promise(o=>this._gracefulShutdownResolve=o),this._isShuttingDown=!1,this._gracefulShutdownResolve=null)}_wrap(o,c,u){return async(...f)=>{f=c(...f);let d={name:o.name,args:f};this._operations.add(d);try{return await this._activate(),await o.apply(this,f)}finally{this._operations.delete(d),u&&this._backend.saveSuperblock(),this._operations.size===0&&(this._deactivationTimeout||clearTimeout(this._deactivationTimeout),this._deactivationTimeout=setTimeout(this._deactivate.bind(this),500))}}}async _activate(){this._initPromise||console.warn(new Error(`Attempted to use LightningFS ${this._name} before it was initialized.`)),await this._initPromise,this._deactivationTimeout&&(clearTimeout(this._deactivationTimeout),this._deactivationTimeout=null),this._deactivationPromise&&await this._deactivationPromise,this._deactivationPromise=null,this._activationPromise||(this._activationPromise=this._backend.activate?this._backend.activate():Promise.resolve()),await this._activationPromise}async _deactivate(){return this._activationPromise&&await this._activationPromise,this._deactivationPromise||(this._deactivationPromise=this._backend.deactivate?this._backend.deactivate():Promise.resolve()),this._activationPromise=null,this._gracefulShutdownResolve&&this._gracefulShutdownResolve(),this._deactivationPromise}async readFile(o,c){return this._backend.readFile(o,c)}async writeFile(o,c,u){return await this._backend.writeFile(o,c,u),null}async unlink(o,c){return await this._backend.unlink(o,c),null}async readdir(o,c){return this._backend.readdir(o,c)}async mkdir(o,c){return await this._backend.mkdir(o,c),null}async rmdir(o,c){return await this._backend.rmdir(o,c),null}async rename(o,c){return await this._backend.rename(o,c),null}async stat(o,c){const u=await this._backend.stat(o,c);return new e(u)}async lstat(o,c){const u=await this._backend.lstat(o,c);return new e(u)}async readlink(o,c){return this._backend.readlink(o,c)}async symlink(o,c){return await this._backend.symlink(o,c),null}async backFile(o,c){return await this._backend.backFile(o,c),null}async du(o){return this._backend.du(o)}async flush(){return this._backend.flush()}},ni}var ai,yn;function Go(){if(yn)return ai;yn=1;const i=Ro(),e=Zo();function t(r,n){return typeof r=="function"&&(n=r),n=i(n),[(...s)=>n(null,...s),n]}return ai=class{constructor(...n){this.promises=new e(...n),this.init=this.init.bind(this),this.readFile=this.readFile.bind(this),this.writeFile=this.writeFile.bind(this),this.unlink=this.unlink.bind(this),this.readdir=this.readdir.bind(this),this.mkdir=this.mkdir.bind(this),this.rmdir=this.rmdir.bind(this),this.rename=this.rename.bind(this),this.stat=this.stat.bind(this),this.lstat=this.lstat.bind(this),this.readlink=this.readlink.bind(this),this.symlink=this.symlink.bind(this),this.backFile=this.backFile.bind(this),this.du=this.du.bind(this),this.flush=this.flush.bind(this)}init(n,a){return this.promises.init(n,a)}readFile(n,a,s){const[o,c]=t(a,s);this.promises.readFile(n,a).then(o).catch(c)}writeFile(n,a,s,o){const[c,u]=t(s,o);this.promises.writeFile(n,a,s).then(c).catch(u)}unlink(n,a,s){const[o,c]=t(a,s);this.promises.unlink(n,a).then(o).catch(c)}readdir(n,a,s){const[o,c]=t(a,s);this.promises.readdir(n,a).then(o).catch(c)}mkdir(n,a,s){const[o,c]=t(a,s);this.promises.mkdir(n,a).then(o).catch(c)}rmdir(n,a,s){const[o,c]=t(a,s);this.promises.rmdir(n,a).then(o).catch(c)}rename(n,a,s){const[o,c]=t(s);this.promises.rename(n,a).then(o).catch(c)}stat(n,a,s){const[o,c]=t(a,s);this.promises.stat(n).then(o).catch(c)}lstat(n,a,s){const[o,c]=t(a,s);this.promises.lstat(n).then(o).catch(c)}readlink(n,a,s){const[o,c]=t(a,s);this.promises.readlink(n).then(o).catch(c)}symlink(n,a,s){const[o,c]=t(s);this.promises.symlink(n,a).then(o).catch(c)}backFile(n,a,s){const[o,c]=t(a,s);this.promises.backFile(n,a).then(o).catch(c)}du(n,a){const[s,o]=t(a);this.promises.du(n).then(s).catch(o)}flush(n){const[a,s]=t(n);this.promises.flush().then(a).catch(s)}},ai}var Wo=Go();const Xo=ut(Wo);var si,kn;function Ko(){if(kn)return si;kn=1;var i=function(e){if(e=e||{},this.Promise=e.Promise||Promise,this.queues=Object.create(null),this.domainReentrant=e.domainReentrant||!1,this.domainReentrant){if(typeof process>"u"||typeof process.domain>"u")throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");this.domains=Object.create(null)}this.timeout=e.timeout||i.DEFAULT_TIMEOUT,this.maxOccupationTime=e.maxOccupationTime||i.DEFAULT_MAX_OCCUPATION_TIME,this.maxExecutionTime=e.maxExecutionTime||i.DEFAULT_MAX_EXECUTION_TIME,e.maxPending===1/0||Number.isInteger(e.maxPending)&&e.maxPending>=0?this.maxPending=e.maxPending:this.maxPending=i.DEFAULT_MAX_PENDING};return i.DEFAULT_TIMEOUT=0,i.DEFAULT_MAX_OCCUPATION_TIME=0,i.DEFAULT_MAX_EXECUTION_TIME=0,i.DEFAULT_MAX_PENDING=1e3,i.prototype.acquire=function(e,t,r,n){if(Array.isArray(e))return this._acquireBatch(e,t,r,n);if(typeof t!="function")throw new Error("You must pass a function to execute");var a=null,s=null,o=null;typeof r!="function"&&(n=r,r=null,o=new this.Promise(function(S,O){a=S,s=O})),n=n||{};var c=!1,u=null,f=null,d=null,h=this,w=function(S,O,I){f&&(clearTimeout(f),f=null),d&&(clearTimeout(d),d=null),S&&(h.queues[e]&&h.queues[e].length===0&&delete h.queues[e],h.domainReentrant&&delete h.domains[e]),c||(o?O?s(O):a(I):typeof r=="function"&&r(O,I),c=!0),S&&h.queues[e]&&h.queues[e].length>0&&h.queues[e].shift()()},_=function(S){if(c)return w(S);u&&(clearTimeout(u),u=null),h.domainReentrant&&S&&(h.domains[e]=process.domain);var O=n.maxExecutionTime||h.maxExecutionTime;if(O&&(d=setTimeout(function(){h.queues[e]&&w(S,new Error("Maximum execution time is exceeded "+e))},O)),t.length===1){var I=!1;try{t(function(A,x){I||(I=!0,w(S,A,x))})}catch(A){I||(I=!0,w(S,A))}}else h._promiseTry(function(){return t()}).then(function(A){w(S,void 0,A)},function(A){w(S,A)})};h.domainReentrant&&process.domain&&(_=process.domain.bind(_));var y=n.maxPending||h.maxPending;if(!h.queues[e])h.queues[e]=[],_(!0);else if(h.domainReentrant&&process.domain&&process.domain===h.domains[e])_(!1);else if(h.queues[e].length>=y)w(!1,new Error("Too many pending tasks in queue "+e));else{var b=function(){_(!0)};n.skipQueue?h.queues[e].unshift(b):h.queues[e].push(b);var v=n.timeout||h.timeout;v&&(u=setTimeout(function(){u=null,w(!1,new Error("async-lock timed out in queue "+e))},v))}var k=n.maxOccupationTime||h.maxOccupationTime;if(k&&(f=setTimeout(function(){h.queues[e]&&w(!1,new Error("Maximum occupation time is exceeded in queue "+e))},k)),o)return o},i.prototype._acquireBatch=function(e,t,r,n){typeof r!="function"&&(n=r,r=null);var a=this,s=function(c,u){return function(f){a.acquire(c,u,f,n)}},o=e.reduceRight(function(c,u){return s(u,c)},t);if(typeof r=="function")o(r);else return new this.Promise(function(c,u){o.length===1?o(function(f,d){f?u(f):c(d)}):c(o())})},i.prototype.isBusy=function(e){return e?!!this.queues[e]:Object.keys(this.queues).length>0},i.prototype._promiseTry=function(e){try{return this.Promise.resolve(e())}catch(t){return this.Promise.reject(t)}},si=i,si}var oi,xn;function Yo(){return xn||(xn=1,oi=Ko()),oi}var Vo=Yo();const tr=ut(Vo);var Er={exports:{}},En;function Jo(){return En||(En=1,typeof Object.create=="function"?Er.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:Er.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}}),Er.exports}var Sr={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var Sn;function ka(){return Sn||(Sn=1,function(i,e){var t=Eo(),r=t.Buffer;function n(s,o){for(var c in s)o[c]=s[c]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?i.exports=t:(n(t,e),e.Buffer=a);function a(s,o,c){return r(s,o,c)}a.prototype=Object.create(r.prototype),n(r,a),a.from=function(s,o,c){if(typeof s=="number")throw new TypeError("Argument must not be a number");return r(s,o,c)},a.alloc=function(s,o,c){if(typeof s!="number")throw new TypeError("Argument must be a number");var u=r(s);return o!==void 0?typeof c=="string"?u.fill(o,c):u.fill(o):u.fill(0),u},a.allocUnsafe=function(s){if(typeof s!="number")throw new TypeError("Argument must be a number");return r(s)},a.allocUnsafeSlow=function(s){if(typeof s!="number")throw new TypeError("Argument must be a number");return t.SlowBuffer(s)}}(Sr,Sr.exports)),Sr.exports}var ci,Rn;function Qo(){if(Rn)return ci;Rn=1;var i=ka().Buffer;function e(t,r){this._block=i.alloc(t),this._finalSize=r,this._blockSize=t,this._len=0}return e.prototype.update=function(t,r){typeof t=="string"&&(r=r||"utf8",t=i.from(t,r));for(var n=this._block,a=this._blockSize,s=t.length,o=this._len,c=0;c<s;){for(var u=o%a,f=Math.min(s-c,a-u),d=0;d<f;d++)n[u+d]=t[c+d];o+=f,c+=f,o%a===0&&this._update(n)}return this._len+=s,this},e.prototype.digest=function(t){var r=this._len%this._blockSize;this._block[r]=128,this._block.fill(0,r+1),r>=this._finalSize&&(this._update(this._block),this._block.fill(0));var n=this._len*8;if(n<=4294967295)this._block.writeUInt32BE(n,this._blockSize-4);else{var a=(n&4294967295)>>>0,s=(n-a)/4294967296;this._block.writeUInt32BE(s,this._blockSize-8),this._block.writeUInt32BE(a,this._blockSize-4)}this._update(this._block);var o=this._hash();return t?o.toString(t):o},e.prototype._update=function(){throw new Error("_update must be implemented by subclass")},ci=e,ci}var fi,Tn;function ec(){if(Tn)return fi;Tn=1;var i=Jo(),e=Qo(),t=ka().Buffer,r=[1518500249,1859775393,-1894007588,-899497514],n=new Array(80);function a(){this.init(),this._w=n,e.call(this,64,56)}i(a,e),a.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this};function s(f){return f<<1|f>>>31}function o(f){return f<<5|f>>>27}function c(f){return f<<30|f>>>2}function u(f,d,h,w){return f===0?d&h|~d&w:f===2?d&h|d&w|h&w:d^h^w}return a.prototype._update=function(f){for(var d=this._w,h=this._a|0,w=this._b|0,_=this._c|0,y=this._d|0,b=this._e|0,v=0;v<16;++v)d[v]=f.readInt32BE(v*4);for(;v<80;++v)d[v]=s(d[v-3]^d[v-8]^d[v-14]^d[v-16]);for(var k=0;k<80;++k){var S=~~(k/20),O=o(h)+u(S,w,_,y)+b+d[k]+r[S]|0;b=y,y=_,_=c(w),w=h,h=O}this._a=h+this._a|0,this._b=w+this._b|0,this._c=_+this._c|0,this._d=y+this._d|0,this._e=b+this._e|0},a.prototype._hash=function(){var f=t.allocUnsafe(20);return f.writeInt32BE(this._a|0,0),f.writeInt32BE(this._b|0,4),f.writeInt32BE(this._c|0,8),f.writeInt32BE(this._d|0,12),f.writeInt32BE(this._e|0,16),f},fi=a,fi}var tc=ec();const xa=ut(tc);var li,$n;function rc(){if($n)return li;$n=1;function i(n){if(typeof n!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(n))}function e(n,a){for(var s="",o=0,c=-1,u=0,f,d=0;d<=n.length;++d){if(d<n.length)f=n.charCodeAt(d);else{if(f===47)break;f=47}if(f===47){if(!(c===d-1||u===1))if(c!==d-1&&u===2){if(s.length<2||o!==2||s.charCodeAt(s.length-1)!==46||s.charCodeAt(s.length-2)!==46){if(s.length>2){var h=s.lastIndexOf("/");if(h!==s.length-1){h===-1?(s="",o=0):(s=s.slice(0,h),o=s.length-1-s.lastIndexOf("/")),c=d,u=0;continue}}else if(s.length===2||s.length===1){s="",o=0,c=d,u=0;continue}}a&&(s.length>0?s+="/..":s="..",o=2)}else s.length>0?s+="/"+n.slice(c+1,d):s=n.slice(c+1,d),o=d-c-1;c=d,u=0}else f===46&&u!==-1?++u:u=-1}return s}function t(n,a){var s=a.dir||a.root,o=a.base||(a.name||"")+(a.ext||"");return s?s===a.root?s+o:s+n+o:o}var r={resolve:function(){for(var a="",s=!1,o,c=arguments.length-1;c>=-1&&!s;c--){var u;c>=0?u=arguments[c]:(o===void 0&&(o=process.cwd()),u=o),i(u),u.length!==0&&(a=u+"/"+a,s=u.charCodeAt(0)===47)}return a=e(a,!s),s?a.length>0?"/"+a:"/":a.length>0?a:"."},normalize:function(a){if(i(a),a.length===0)return".";var s=a.charCodeAt(0)===47,o=a.charCodeAt(a.length-1)===47;return a=e(a,!s),a.length===0&&!s&&(a="."),a.length>0&&o&&(a+="/"),s?"/"+a:a},isAbsolute:function(a){return i(a),a.length>0&&a.charCodeAt(0)===47},join:function(){if(arguments.length===0)return".";for(var a,s=0;s<arguments.length;++s){var o=arguments[s];i(o),o.length>0&&(a===void 0?a=o:a+="/"+o)}return a===void 0?".":r.normalize(a)},relative:function(a,s){if(i(a),i(s),a===s||(a=r.resolve(a),s=r.resolve(s),a===s))return"";for(var o=1;o<a.length&&a.charCodeAt(o)===47;++o);for(var c=a.length,u=c-o,f=1;f<s.length&&s.charCodeAt(f)===47;++f);for(var d=s.length,h=d-f,w=u<h?u:h,_=-1,y=0;y<=w;++y){if(y===w){if(h>w){if(s.charCodeAt(f+y)===47)return s.slice(f+y+1);if(y===0)return s.slice(f+y)}else u>w&&(a.charCodeAt(o+y)===47?_=y:y===0&&(_=0));break}var b=a.charCodeAt(o+y),v=s.charCodeAt(f+y);if(b!==v)break;b===47&&(_=y)}var k="";for(y=o+_+1;y<=c;++y)(y===c||a.charCodeAt(y)===47)&&(k.length===0?k+="..":k+="/..");return k.length>0?k+s.slice(f+_):(f+=_,s.charCodeAt(f)===47&&++f,s.slice(f))},_makeLong:function(a){return a},dirname:function(a){if(i(a),a.length===0)return".";for(var s=a.charCodeAt(0),o=s===47,c=-1,u=!0,f=a.length-1;f>=1;--f)if(s=a.charCodeAt(f),s===47){if(!u){c=f;break}}else u=!1;return c===-1?o?"/":".":o&&c===1?"//":a.slice(0,c)},basename:function(a,s){if(s!==void 0&&typeof s!="string")throw new TypeError('"ext" argument must be a string');i(a);var o=0,c=-1,u=!0,f;if(s!==void 0&&s.length>0&&s.length<=a.length){if(s.length===a.length&&s===a)return"";var d=s.length-1,h=-1;for(f=a.length-1;f>=0;--f){var w=a.charCodeAt(f);if(w===47){if(!u){o=f+1;break}}else h===-1&&(u=!1,h=f+1),d>=0&&(w===s.charCodeAt(d)?--d===-1&&(c=f):(d=-1,c=h))}return o===c?c=h:c===-1&&(c=a.length),a.slice(o,c)}else{for(f=a.length-1;f>=0;--f)if(a.charCodeAt(f)===47){if(!u){o=f+1;break}}else c===-1&&(u=!1,c=f+1);return c===-1?"":a.slice(o,c)}},extname:function(a){i(a);for(var s=-1,o=0,c=-1,u=!0,f=0,d=a.length-1;d>=0;--d){var h=a.charCodeAt(d);if(h===47){if(!u){o=d+1;break}continue}c===-1&&(u=!1,c=d+1),h===46?s===-1?s=d:f!==1&&(f=1):s!==-1&&(f=-1)}return s===-1||c===-1||f===0||f===1&&s===c-1&&s===o+1?"":a.slice(s,c)},format:function(a){if(a===null||typeof a!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof a);return t("/",a)},parse:function(a){i(a);var s={root:"",dir:"",base:"",ext:"",name:""};if(a.length===0)return s;var o=a.charCodeAt(0),c=o===47,u;c?(s.root="/",u=1):u=0;for(var f=-1,d=0,h=-1,w=!0,_=a.length-1,y=0;_>=u;--_){if(o=a.charCodeAt(_),o===47){if(!w){d=_+1;break}continue}h===-1&&(w=!1,h=_+1),o===46?f===-1?f=_:y!==1&&(y=1):f!==-1&&(y=-1)}return f===-1||h===-1||y===0||y===1&&f===h-1&&f===d+1?h!==-1&&(d===0&&c?s.base=s.name=a.slice(1,h):s.base=s.name=a.slice(d,h)):(d===0&&c?(s.name=a.slice(1,f),s.base=a.slice(1,h)):(s.name=a.slice(d,f),s.base=a.slice(d,h)),s.ext=a.slice(f,h)),d>0?s.dir=a.slice(0,d-1):c&&(s.dir="/"),s},sep:"/",delimiter:":",win32:null,posix:null};return r.posix=r,li=r,li}var M=rc(),ui={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */var An;function ic(){return An||(An=1,function(i){(function(e){e(typeof DO_NOT_EXPORT_CRC>"u"?i:{})})(function(e){e.version="1.2.2";function t(){for(var R=0,D=new Array(256),j=0;j!=256;++j)R=j,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,R=R&1?-306674912^R>>>1:R>>>1,D[j]=R;return typeof Int32Array<"u"?new Int32Array(D):D}var r=t();function n(R){var D=0,j=0,H=0,L=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(H=0;H!=256;++H)L[H]=R[H];for(H=0;H!=256;++H)for(j=R[H],D=256+H;D<4096;D+=256)j=L[D]=j>>>8^R[j&255];var F=[];for(H=1;H!=16;++H)F[H-1]=typeof Int32Array<"u"?L.subarray(H*256,H*256+256):L.slice(H*256,H*256+256);return F}var a=n(r),s=a[0],o=a[1],c=a[2],u=a[3],f=a[4],d=a[5],h=a[6],w=a[7],_=a[8],y=a[9],b=a[10],v=a[11],k=a[12],S=a[13],O=a[14];function I(R,D){for(var j=D^-1,H=0,L=R.length;H<L;)j=j>>>8^r[(j^R.charCodeAt(H++))&255];return~j}function A(R,D){for(var j=D^-1,H=R.length-15,L=0;L<H;)j=O[R[L++]^j&255]^S[R[L++]^j>>8&255]^k[R[L++]^j>>16&255]^v[R[L++]^j>>>24]^b[R[L++]]^y[R[L++]]^_[R[L++]]^w[R[L++]]^h[R[L++]]^d[R[L++]]^f[R[L++]]^u[R[L++]]^c[R[L++]]^o[R[L++]]^s[R[L++]]^r[R[L++]];for(H+=15;L<H;)j=j>>>8^r[(j^R[L++])&255];return~j}function x(R,D){for(var j=D^-1,H=0,L=R.length,F=0,K=0;H<L;)F=R.charCodeAt(H++),F<128?j=j>>>8^r[(j^F)&255]:F<2048?(j=j>>>8^r[(j^(192|F>>6&31))&255],j=j>>>8^r[(j^(128|F&63))&255]):F>=55296&&F<57344?(F=(F&1023)+64,K=R.charCodeAt(H++)&1023,j=j>>>8^r[(j^(240|F>>8&7))&255],j=j>>>8^r[(j^(128|F>>2&63))&255],j=j>>>8^r[(j^(128|K>>6&15|(F&3)<<4))&255],j=j>>>8^r[(j^(128|K&63))&255]):(j=j>>>8^r[(j^(224|F>>12&15))&255],j=j>>>8^r[(j^(128|F>>6&63))&255],j=j>>>8^r[(j^(128|F&63))&255]);return~j}e.table=r,e.bstr=I,e.buf=A,e.str=x})}(ui)),ui}var nc=ic();const ac=ut(nc);var hi={},On;function yt(){return On||(On=1,function(i){var e=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";function t(a,s){return Object.prototype.hasOwnProperty.call(a,s)}i.assign=function(a){for(var s=Array.prototype.slice.call(arguments,1);s.length;){var o=s.shift();if(o){if(typeof o!="object")throw new TypeError(o+"must be non-object");for(var c in o)t(o,c)&&(a[c]=o[c])}}return a},i.shrinkBuf=function(a,s){return a.length===s?a:a.subarray?a.subarray(0,s):(a.length=s,a)};var r={arraySet:function(a,s,o,c,u){if(s.subarray&&a.subarray){a.set(s.subarray(o,o+c),u);return}for(var f=0;f<c;f++)a[u+f]=s[o+f]},flattenChunks:function(a){var s,o,c,u,f,d;for(c=0,s=0,o=a.length;s<o;s++)c+=a[s].length;for(d=new Uint8Array(c),u=0,s=0,o=a.length;s<o;s++)f=a[s],d.set(f,u),u+=f.length;return d}},n={arraySet:function(a,s,o,c,u){for(var f=0;f<c;f++)a[u+f]=s[o+f]},flattenChunks:function(a){return[].concat.apply([],a)}};i.setTyped=function(a){a?(i.Buf8=Uint8Array,i.Buf16=Uint16Array,i.Buf32=Int32Array,i.assign(i,r)):(i.Buf8=Array,i.Buf16=Array,i.Buf32=Array,i.assign(i,n))},i.setTyped(e)}(hi)),hi}var Dt={},Je={},xt={},In;function sc(){if(In)return xt;In=1;var i=yt(),e=4,t=0,r=1,n=2;function a(g){for(var q=g.length;--q>=0;)g[q]=0}var s=0,o=1,c=2,u=3,f=258,d=29,h=256,w=h+1+d,_=30,y=19,b=2*w+1,v=15,k=16,S=7,O=256,I=16,A=17,x=18,R=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],D=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],j=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],H=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],L=512,F=new Array((w+2)*2);a(F);var K=new Array(_*2);a(K);var ce=new Array(L);a(ce);var ge=new Array(f-u+1);a(ge);var N=new Array(d);a(N);var U=new Array(_);a(U);function X(g,q,W,J,$){this.static_tree=g,this.extra_bits=q,this.extra_base=W,this.elems=J,this.max_length=$,this.has_stree=g&&g.length}var ae,ie,re;function le(g,q){this.dyn_tree=g,this.max_code=0,this.stat_desc=q}function we(g){return g<256?ce[g]:ce[256+(g>>>7)]}function ye(g,q){g.pending_buf[g.pending++]=q&255,g.pending_buf[g.pending++]=q>>>8&255}function ue(g,q,W){g.bi_valid>k-W?(g.bi_buf|=q<<g.bi_valid&65535,ye(g,g.bi_buf),g.bi_buf=q>>k-g.bi_valid,g.bi_valid+=W-k):(g.bi_buf|=q<<g.bi_valid&65535,g.bi_valid+=W)}function oe(g,q,W){ue(g,W[q*2],W[q*2+1])}function pe(g,q){var W=0;do W|=g&1,g>>>=1,W<<=1;while(--q>0);return W>>>1}function Re(g){g.bi_valid===16?(ye(g,g.bi_buf),g.bi_buf=0,g.bi_valid=0):g.bi_valid>=8&&(g.pending_buf[g.pending++]=g.bi_buf&255,g.bi_buf>>=8,g.bi_valid-=8)}function Me(g,q){var W=q.dyn_tree,J=q.max_code,$=q.stat_desc.static_tree,z=q.stat_desc.has_stree,m=q.stat_desc.extra_bits,Z=q.stat_desc.extra_base,ne=q.stat_desc.max_length,l,C,P,p,E,B,ee=0;for(p=0;p<=v;p++)g.bl_count[p]=0;for(W[g.heap[g.heap_max]*2+1]=0,l=g.heap_max+1;l<b;l++)C=g.heap[l],p=W[W[C*2+1]*2+1]+1,p>ne&&(p=ne,ee++),W[C*2+1]=p,!(C>J)&&(g.bl_count[p]++,E=0,C>=Z&&(E=m[C-Z]),B=W[C*2],g.opt_len+=B*(p+E),z&&(g.static_len+=B*($[C*2+1]+E)));if(ee!==0){do{for(p=ne-1;g.bl_count[p]===0;)p--;g.bl_count[p]--,g.bl_count[p+1]+=2,g.bl_count[ne]--,ee-=2}while(ee>0);for(p=ne;p!==0;p--)for(C=g.bl_count[p];C!==0;)P=g.heap[--l],!(P>J)&&(W[P*2+1]!==p&&(g.opt_len+=(p-W[P*2+1])*W[P*2],W[P*2+1]=p),C--)}}function je(g,q,W){var J=new Array(v+1),$=0,z,m;for(z=1;z<=v;z++)J[z]=$=$+W[z-1]<<1;for(m=0;m<=q;m++){var Z=g[m*2+1];Z!==0&&(g[m*2]=pe(J[Z]++,Z))}}function te(){var g,q,W,J,$,z=new Array(v+1);for(W=0,J=0;J<d-1;J++)for(N[J]=W,g=0;g<1<<R[J];g++)ge[W++]=J;for(ge[W-1]=J,$=0,J=0;J<16;J++)for(U[J]=$,g=0;g<1<<D[J];g++)ce[$++]=J;for($>>=7;J<_;J++)for(U[J]=$<<7,g=0;g<1<<D[J]-7;g++)ce[256+$++]=J;for(q=0;q<=v;q++)z[q]=0;for(g=0;g<=143;)F[g*2+1]=8,g++,z[8]++;for(;g<=255;)F[g*2+1]=9,g++,z[9]++;for(;g<=279;)F[g*2+1]=7,g++,z[7]++;for(;g<=287;)F[g*2+1]=8,g++,z[8]++;for(je(F,w+1,z),g=0;g<_;g++)K[g*2+1]=5,K[g*2]=pe(g,5);ae=new X(F,R,h+1,w,v),ie=new X(K,D,0,_,v),re=new X(new Array(0),j,0,y,S)}function _e(g){var q;for(q=0;q<w;q++)g.dyn_ltree[q*2]=0;for(q=0;q<_;q++)g.dyn_dtree[q*2]=0;for(q=0;q<y;q++)g.bl_tree[q*2]=0;g.dyn_ltree[O*2]=1,g.opt_len=g.static_len=0,g.last_lit=g.matches=0}function $e(g){g.bi_valid>8?ye(g,g.bi_buf):g.bi_valid>0&&(g.pending_buf[g.pending++]=g.bi_buf),g.bi_buf=0,g.bi_valid=0}function Ee(g,q,W,J){$e(g),ye(g,W),ye(g,~W),i.arraySet(g.pending_buf,g.window,q,W,g.pending),g.pending+=W}function Ce(g,q,W,J){var $=q*2,z=W*2;return g[$]<g[z]||g[$]===g[z]&&J[q]<=J[W]}function ve(g,q,W){for(var J=g.heap[W],$=W<<1;$<=g.heap_len&&($<g.heap_len&&Ce(q,g.heap[$+1],g.heap[$],g.depth)&&$++,!Ce(q,J,g.heap[$],g.depth));)g.heap[W]=g.heap[$],W=$,$<<=1;g.heap[W]=J}function fe(g,q,W){var J,$,z=0,m,Z;if(g.last_lit!==0)do J=g.pending_buf[g.d_buf+z*2]<<8|g.pending_buf[g.d_buf+z*2+1],$=g.pending_buf[g.l_buf+z],z++,J===0?oe(g,$,q):(m=ge[$],oe(g,m+h+1,q),Z=R[m],Z!==0&&($-=N[m],ue(g,$,Z)),J--,m=we(J),oe(g,m,W),Z=D[m],Z!==0&&(J-=U[m],ue(g,J,Z)));while(z<g.last_lit);oe(g,O,q)}function We(g,q){var W=q.dyn_tree,J=q.stat_desc.static_tree,$=q.stat_desc.has_stree,z=q.stat_desc.elems,m,Z,ne=-1,l;for(g.heap_len=0,g.heap_max=b,m=0;m<z;m++)W[m*2]!==0?(g.heap[++g.heap_len]=ne=m,g.depth[m]=0):W[m*2+1]=0;for(;g.heap_len<2;)l=g.heap[++g.heap_len]=ne<2?++ne:0,W[l*2]=1,g.depth[l]=0,g.opt_len--,$&&(g.static_len-=J[l*2+1]);for(q.max_code=ne,m=g.heap_len>>1;m>=1;m--)ve(g,W,m);l=z;do m=g.heap[1],g.heap[1]=g.heap[g.heap_len--],ve(g,W,1),Z=g.heap[1],g.heap[--g.heap_max]=m,g.heap[--g.heap_max]=Z,W[l*2]=W[m*2]+W[Z*2],g.depth[l]=(g.depth[m]>=g.depth[Z]?g.depth[m]:g.depth[Z])+1,W[m*2+1]=W[Z*2+1]=l,g.heap[1]=l++,ve(g,W,1);while(g.heap_len>=2);g.heap[--g.heap_max]=g.heap[1],Me(g,q),je(W,ne,g.bl_count)}function It(g,q,W){var J,$=-1,z,m=q[0*2+1],Z=0,ne=7,l=4;for(m===0&&(ne=138,l=3),q[(W+1)*2+1]=65535,J=0;J<=W;J++)z=m,m=q[(J+1)*2+1],!(++Z<ne&&z===m)&&(Z<l?g.bl_tree[z*2]+=Z:z!==0?(z!==$&&g.bl_tree[z*2]++,g.bl_tree[I*2]++):Z<=10?g.bl_tree[A*2]++:g.bl_tree[x*2]++,Z=0,$=z,m===0?(ne=138,l=3):z===m?(ne=6,l=3):(ne=7,l=4))}function ht(g,q,W){var J,$=-1,z,m=q[0*2+1],Z=0,ne=7,l=4;for(m===0&&(ne=138,l=3),J=0;J<=W;J++)if(z=m,m=q[(J+1)*2+1],!(++Z<ne&&z===m)){if(Z<l)do oe(g,z,g.bl_tree);while(--Z!==0);else z!==0?(z!==$&&(oe(g,z,g.bl_tree),Z--),oe(g,I,g.bl_tree),ue(g,Z-3,2)):Z<=10?(oe(g,A,g.bl_tree),ue(g,Z-3,3)):(oe(g,x,g.bl_tree),ue(g,Z-11,7));Z=0,$=z,m===0?(ne=138,l=3):z===m?(ne=6,l=3):(ne=7,l=4)}}function Xe(g){var q;for(It(g,g.dyn_ltree,g.l_desc.max_code),It(g,g.dyn_dtree,g.d_desc.max_code),We(g,g.bl_desc),q=y-1;q>=3&&g.bl_tree[H[q]*2+1]===0;q--);return g.opt_len+=3*(q+1)+5+5+4,q}function jt(g,q,W,J){var $;for(ue(g,q-257,5),ue(g,W-1,5),ue(g,J-4,4),$=0;$<J;$++)ue(g,g.bl_tree[H[$]*2+1],3);ht(g,g.dyn_ltree,q-1),ht(g,g.dyn_dtree,W-1)}function dt(g){var q=4093624447,W;for(W=0;W<=31;W++,q>>>=1)if(q&1&&g.dyn_ltree[W*2]!==0)return t;if(g.dyn_ltree[9*2]!==0||g.dyn_ltree[10*2]!==0||g.dyn_ltree[13*2]!==0)return r;for(W=32;W<h;W++)if(g.dyn_ltree[W*2]!==0)return r;return t}var Ve=!1;function Bt(g){Ve||(te(),Ve=!0),g.l_desc=new le(g.dyn_ltree,ae),g.d_desc=new le(g.dyn_dtree,ie),g.bl_desc=new le(g.bl_tree,re),g.bi_buf=0,g.bi_valid=0,_e(g)}function wt(g,q,W,J){ue(g,(s<<1)+(J?1:0),3),Ee(g,q,W)}function Pe(g){ue(g,o<<1,3),oe(g,O,F),Re(g)}function tt(g,q,W,J){var $,z,m=0;g.level>0?(g.strm.data_type===n&&(g.strm.data_type=dt(g)),We(g,g.l_desc),We(g,g.d_desc),m=Xe(g),$=g.opt_len+3+7>>>3,z=g.static_len+3+7>>>3,z<=$&&($=z)):$=z=W+5,W+4<=$&&q!==-1?wt(g,q,W,J):g.strategy===e||z===$?(ue(g,(o<<1)+(J?1:0),3),fe(g,F,K)):(ue(g,(c<<1)+(J?1:0),3),jt(g,g.l_desc.max_code+1,g.d_desc.max_code+1,m+1),fe(g,g.dyn_ltree,g.dyn_dtree)),_e(g),J&&$e(g)}function Ct(g,q,W){return g.pending_buf[g.d_buf+g.last_lit*2]=q>>>8&255,g.pending_buf[g.d_buf+g.last_lit*2+1]=q&255,g.pending_buf[g.l_buf+g.last_lit]=W&255,g.last_lit++,q===0?g.dyn_ltree[W*2]++:(g.matches++,q--,g.dyn_ltree[(ge[W]+h+1)*2]++,g.dyn_dtree[we(q)*2]++),g.last_lit===g.lit_bufsize-1}return xt._tr_init=Bt,xt._tr_stored_block=wt,xt._tr_flush_block=tt,xt._tr_tally=Ct,xt._tr_align=Pe,xt}var di,jn;function Ea(){if(jn)return di;jn=1;function i(e,t,r,n){for(var a=e&65535|0,s=e>>>16&65535|0,o=0;r!==0;){o=r>2e3?2e3:r,r-=o;do a=a+t[n++]|0,s=s+a|0;while(--o);a%=65521,s%=65521}return a|s<<16|0}return di=i,di}var wi,Bn;function Sa(){if(Bn)return wi;Bn=1;function i(){for(var r,n=[],a=0;a<256;a++){r=a;for(var s=0;s<8;s++)r=r&1?3988292384^r>>>1:r>>>1;n[a]=r}return n}var e=i();function t(r,n,a,s){var o=e,c=s+a;r^=-1;for(var u=s;u<c;u++)r=r>>>8^o[(r^n[u])&255];return r^-1}return wi=t,wi}var mi,Cn;function Gi(){return Cn||(Cn=1,mi={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}),mi}var Dn;function oc(){if(Dn)return Je;Dn=1;var i=yt(),e=sc(),t=Ea(),r=Sa(),n=Gi(),a=0,s=1,o=3,c=4,u=5,f=0,d=1,h=-2,w=-3,_=-5,y=-1,b=1,v=2,k=3,S=4,O=0,I=2,A=8,x=9,R=15,D=8,j=29,H=256,L=H+1+j,F=30,K=19,ce=2*L+1,ge=15,N=3,U=258,X=U+N+1,ae=32,ie=42,re=69,le=73,we=91,ye=103,ue=113,oe=666,pe=1,Re=2,Me=3,je=4,te=3;function _e(l,C){return l.msg=n[C],C}function $e(l){return(l<<1)-(l>4?9:0)}function Ee(l){for(var C=l.length;--C>=0;)l[C]=0}function Ce(l){var C=l.state,P=C.pending;P>l.avail_out&&(P=l.avail_out),P!==0&&(i.arraySet(l.output,C.pending_buf,C.pending_out,P,l.next_out),l.next_out+=P,C.pending_out+=P,l.total_out+=P,l.avail_out-=P,C.pending-=P,C.pending===0&&(C.pending_out=0))}function ve(l,C){e._tr_flush_block(l,l.block_start>=0?l.block_start:-1,l.strstart-l.block_start,C),l.block_start=l.strstart,Ce(l.strm)}function fe(l,C){l.pending_buf[l.pending++]=C}function We(l,C){l.pending_buf[l.pending++]=C>>>8&255,l.pending_buf[l.pending++]=C&255}function It(l,C,P,p){var E=l.avail_in;return E>p&&(E=p),E===0?0:(l.avail_in-=E,i.arraySet(C,l.input,l.next_in,E,P),l.state.wrap===1?l.adler=t(l.adler,C,E,P):l.state.wrap===2&&(l.adler=r(l.adler,C,E,P)),l.next_in+=E,l.total_in+=E,E)}function ht(l,C){var P=l.max_chain_length,p=l.strstart,E,B,ee=l.prev_length,Y=l.nice_match,V=l.strstart>l.w_size-X?l.strstart-(l.w_size-X):0,he=l.window,st=l.w_mask,Se=l.prev,me=l.strstart+U,Ie=he[p+ee-1],Ne=he[p+ee];l.prev_length>=l.good_match&&(P>>=2),Y>l.lookahead&&(Y=l.lookahead);do if(E=C,!(he[E+ee]!==Ne||he[E+ee-1]!==Ie||he[E]!==he[p]||he[++E]!==he[p+1])){p+=2,E++;do;while(he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&he[++p]===he[++E]&&p<me);if(B=U-(me-p),p=me-U,B>ee){if(l.match_start=C,ee=B,B>=Y)break;Ie=he[p+ee-1],Ne=he[p+ee]}}while((C=Se[C&st])>V&&--P!==0);return ee<=l.lookahead?ee:l.lookahead}function Xe(l){var C=l.w_size,P,p,E,B,ee;do{if(B=l.window_size-l.lookahead-l.strstart,l.strstart>=C+(C-X)){i.arraySet(l.window,l.window,C,C,0),l.match_start-=C,l.strstart-=C,l.block_start-=C,p=l.hash_size,P=p;do E=l.head[--P],l.head[P]=E>=C?E-C:0;while(--p);p=C,P=p;do E=l.prev[--P],l.prev[P]=E>=C?E-C:0;while(--p);B+=C}if(l.strm.avail_in===0)break;if(p=It(l.strm,l.window,l.strstart+l.lookahead,B),l.lookahead+=p,l.lookahead+l.insert>=N)for(ee=l.strstart-l.insert,l.ins_h=l.window[ee],l.ins_h=(l.ins_h<<l.hash_shift^l.window[ee+1])&l.hash_mask;l.insert&&(l.ins_h=(l.ins_h<<l.hash_shift^l.window[ee+N-1])&l.hash_mask,l.prev[ee&l.w_mask]=l.head[l.ins_h],l.head[l.ins_h]=ee,ee++,l.insert--,!(l.lookahead+l.insert<N)););}while(l.lookahead<X&&l.strm.avail_in!==0)}function jt(l,C){var P=65535;for(P>l.pending_buf_size-5&&(P=l.pending_buf_size-5);;){if(l.lookahead<=1){if(Xe(l),l.lookahead===0&&C===a)return pe;if(l.lookahead===0)break}l.strstart+=l.lookahead,l.lookahead=0;var p=l.block_start+P;if((l.strstart===0||l.strstart>=p)&&(l.lookahead=l.strstart-p,l.strstart=p,ve(l,!1),l.strm.avail_out===0)||l.strstart-l.block_start>=l.w_size-X&&(ve(l,!1),l.strm.avail_out===0))return pe}return l.insert=0,C===c?(ve(l,!0),l.strm.avail_out===0?Me:je):(l.strstart>l.block_start&&(ve(l,!1),l.strm.avail_out===0),pe)}function dt(l,C){for(var P,p;;){if(l.lookahead<X){if(Xe(l),l.lookahead<X&&C===a)return pe;if(l.lookahead===0)break}if(P=0,l.lookahead>=N&&(l.ins_h=(l.ins_h<<l.hash_shift^l.window[l.strstart+N-1])&l.hash_mask,P=l.prev[l.strstart&l.w_mask]=l.head[l.ins_h],l.head[l.ins_h]=l.strstart),P!==0&&l.strstart-P<=l.w_size-X&&(l.match_length=ht(l,P)),l.match_length>=N)if(p=e._tr_tally(l,l.strstart-l.match_start,l.match_length-N),l.lookahead-=l.match_length,l.match_length<=l.max_lazy_match&&l.lookahead>=N){l.match_length--;do l.strstart++,l.ins_h=(l.ins_h<<l.hash_shift^l.window[l.strstart+N-1])&l.hash_mask,P=l.prev[l.strstart&l.w_mask]=l.head[l.ins_h],l.head[l.ins_h]=l.strstart;while(--l.match_length!==0);l.strstart++}else l.strstart+=l.match_length,l.match_length=0,l.ins_h=l.window[l.strstart],l.ins_h=(l.ins_h<<l.hash_shift^l.window[l.strstart+1])&l.hash_mask;else p=e._tr_tally(l,0,l.window[l.strstart]),l.lookahead--,l.strstart++;if(p&&(ve(l,!1),l.strm.avail_out===0))return pe}return l.insert=l.strstart<N-1?l.strstart:N-1,C===c?(ve(l,!0),l.strm.avail_out===0?Me:je):l.last_lit&&(ve(l,!1),l.strm.avail_out===0)?pe:Re}function Ve(l,C){for(var P,p,E;;){if(l.lookahead<X){if(Xe(l),l.lookahead<X&&C===a)return pe;if(l.lookahead===0)break}if(P=0,l.lookahead>=N&&(l.ins_h=(l.ins_h<<l.hash_shift^l.window[l.strstart+N-1])&l.hash_mask,P=l.prev[l.strstart&l.w_mask]=l.head[l.ins_h],l.head[l.ins_h]=l.strstart),l.prev_length=l.match_length,l.prev_match=l.match_start,l.match_length=N-1,P!==0&&l.prev_length<l.max_lazy_match&&l.strstart-P<=l.w_size-X&&(l.match_length=ht(l,P),l.match_length<=5&&(l.strategy===b||l.match_length===N&&l.strstart-l.match_start>4096)&&(l.match_length=N-1)),l.prev_length>=N&&l.match_length<=l.prev_length){E=l.strstart+l.lookahead-N,p=e._tr_tally(l,l.strstart-1-l.prev_match,l.prev_length-N),l.lookahead-=l.prev_length-1,l.prev_length-=2;do++l.strstart<=E&&(l.ins_h=(l.ins_h<<l.hash_shift^l.window[l.strstart+N-1])&l.hash_mask,P=l.prev[l.strstart&l.w_mask]=l.head[l.ins_h],l.head[l.ins_h]=l.strstart);while(--l.prev_length!==0);if(l.match_available=0,l.match_length=N-1,l.strstart++,p&&(ve(l,!1),l.strm.avail_out===0))return pe}else if(l.match_available){if(p=e._tr_tally(l,0,l.window[l.strstart-1]),p&&ve(l,!1),l.strstart++,l.lookahead--,l.strm.avail_out===0)return pe}else l.match_available=1,l.strstart++,l.lookahead--}return l.match_available&&(p=e._tr_tally(l,0,l.window[l.strstart-1]),l.match_available=0),l.insert=l.strstart<N-1?l.strstart:N-1,C===c?(ve(l,!0),l.strm.avail_out===0?Me:je):l.last_lit&&(ve(l,!1),l.strm.avail_out===0)?pe:Re}function Bt(l,C){for(var P,p,E,B,ee=l.window;;){if(l.lookahead<=U){if(Xe(l),l.lookahead<=U&&C===a)return pe;if(l.lookahead===0)break}if(l.match_length=0,l.lookahead>=N&&l.strstart>0&&(E=l.strstart-1,p=ee[E],p===ee[++E]&&p===ee[++E]&&p===ee[++E])){B=l.strstart+U;do;while(p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&p===ee[++E]&&E<B);l.match_length=U-(B-E),l.match_length>l.lookahead&&(l.match_length=l.lookahead)}if(l.match_length>=N?(P=e._tr_tally(l,1,l.match_length-N),l.lookahead-=l.match_length,l.strstart+=l.match_length,l.match_length=0):(P=e._tr_tally(l,0,l.window[l.strstart]),l.lookahead--,l.strstart++),P&&(ve(l,!1),l.strm.avail_out===0))return pe}return l.insert=0,C===c?(ve(l,!0),l.strm.avail_out===0?Me:je):l.last_lit&&(ve(l,!1),l.strm.avail_out===0)?pe:Re}function wt(l,C){for(var P;;){if(l.lookahead===0&&(Xe(l),l.lookahead===0)){if(C===a)return pe;break}if(l.match_length=0,P=e._tr_tally(l,0,l.window[l.strstart]),l.lookahead--,l.strstart++,P&&(ve(l,!1),l.strm.avail_out===0))return pe}return l.insert=0,C===c?(ve(l,!0),l.strm.avail_out===0?Me:je):l.last_lit&&(ve(l,!1),l.strm.avail_out===0)?pe:Re}function Pe(l,C,P,p,E){this.good_length=l,this.max_lazy=C,this.nice_length=P,this.max_chain=p,this.func=E}var tt;tt=[new Pe(0,0,0,0,jt),new Pe(4,4,8,4,dt),new Pe(4,5,16,8,dt),new Pe(4,6,32,32,dt),new Pe(4,4,16,16,Ve),new Pe(8,16,32,32,Ve),new Pe(8,16,128,128,Ve),new Pe(8,32,128,256,Ve),new Pe(32,128,258,1024,Ve),new Pe(32,258,258,4096,Ve)];function Ct(l){l.window_size=2*l.w_size,Ee(l.head),l.max_lazy_match=tt[l.level].max_lazy,l.good_match=tt[l.level].good_length,l.nice_match=tt[l.level].nice_length,l.max_chain_length=tt[l.level].max_chain,l.strstart=0,l.block_start=0,l.lookahead=0,l.insert=0,l.match_length=l.prev_length=N-1,l.match_available=0,l.ins_h=0}function g(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=A,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new i.Buf16(ce*2),this.dyn_dtree=new i.Buf16((2*F+1)*2),this.bl_tree=new i.Buf16((2*K+1)*2),Ee(this.dyn_ltree),Ee(this.dyn_dtree),Ee(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new i.Buf16(ge+1),this.heap=new i.Buf16(2*L+1),Ee(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new i.Buf16(2*L+1),Ee(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function q(l){var C;return!l||!l.state?_e(l,h):(l.total_in=l.total_out=0,l.data_type=I,C=l.state,C.pending=0,C.pending_out=0,C.wrap<0&&(C.wrap=-C.wrap),C.status=C.wrap?ie:ue,l.adler=C.wrap===2?0:1,C.last_flush=a,e._tr_init(C),f)}function W(l){var C=q(l);return C===f&&Ct(l.state),C}function J(l,C){return!l||!l.state||l.state.wrap!==2?h:(l.state.gzhead=C,f)}function $(l,C,P,p,E,B){if(!l)return h;var ee=1;if(C===y&&(C=6),p<0?(ee=0,p=-p):p>15&&(ee=2,p-=16),E<1||E>x||P!==A||p<8||p>15||C<0||C>9||B<0||B>S)return _e(l,h);p===8&&(p=9);var Y=new g;return l.state=Y,Y.strm=l,Y.wrap=ee,Y.gzhead=null,Y.w_bits=p,Y.w_size=1<<Y.w_bits,Y.w_mask=Y.w_size-1,Y.hash_bits=E+7,Y.hash_size=1<<Y.hash_bits,Y.hash_mask=Y.hash_size-1,Y.hash_shift=~~((Y.hash_bits+N-1)/N),Y.window=new i.Buf8(Y.w_size*2),Y.head=new i.Buf16(Y.hash_size),Y.prev=new i.Buf16(Y.w_size),Y.lit_bufsize=1<<E+6,Y.pending_buf_size=Y.lit_bufsize*4,Y.pending_buf=new i.Buf8(Y.pending_buf_size),Y.d_buf=1*Y.lit_bufsize,Y.l_buf=3*Y.lit_bufsize,Y.level=C,Y.strategy=B,Y.method=P,W(l)}function z(l,C){return $(l,C,A,R,D,O)}function m(l,C){var P,p,E,B;if(!l||!l.state||C>u||C<0)return l?_e(l,h):h;if(p=l.state,!l.output||!l.input&&l.avail_in!==0||p.status===oe&&C!==c)return _e(l,l.avail_out===0?_:h);if(p.strm=l,P=p.last_flush,p.last_flush=C,p.status===ie)if(p.wrap===2)l.adler=0,fe(p,31),fe(p,139),fe(p,8),p.gzhead?(fe(p,(p.gzhead.text?1:0)+(p.gzhead.hcrc?2:0)+(p.gzhead.extra?4:0)+(p.gzhead.name?8:0)+(p.gzhead.comment?16:0)),fe(p,p.gzhead.time&255),fe(p,p.gzhead.time>>8&255),fe(p,p.gzhead.time>>16&255),fe(p,p.gzhead.time>>24&255),fe(p,p.level===9?2:p.strategy>=v||p.level<2?4:0),fe(p,p.gzhead.os&255),p.gzhead.extra&&p.gzhead.extra.length&&(fe(p,p.gzhead.extra.length&255),fe(p,p.gzhead.extra.length>>8&255)),p.gzhead.hcrc&&(l.adler=r(l.adler,p.pending_buf,p.pending,0)),p.gzindex=0,p.status=re):(fe(p,0),fe(p,0),fe(p,0),fe(p,0),fe(p,0),fe(p,p.level===9?2:p.strategy>=v||p.level<2?4:0),fe(p,te),p.status=ue);else{var ee=A+(p.w_bits-8<<4)<<8,Y=-1;p.strategy>=v||p.level<2?Y=0:p.level<6?Y=1:p.level===6?Y=2:Y=3,ee|=Y<<6,p.strstart!==0&&(ee|=ae),ee+=31-ee%31,p.status=ue,We(p,ee),p.strstart!==0&&(We(p,l.adler>>>16),We(p,l.adler&65535)),l.adler=1}if(p.status===re)if(p.gzhead.extra){for(E=p.pending;p.gzindex<(p.gzhead.extra.length&65535)&&!(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),Ce(l),E=p.pending,p.pending===p.pending_buf_size));)fe(p,p.gzhead.extra[p.gzindex]&255),p.gzindex++;p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),p.gzindex===p.gzhead.extra.length&&(p.gzindex=0,p.status=le)}else p.status=le;if(p.status===le)if(p.gzhead.name){E=p.pending;do{if(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),Ce(l),E=p.pending,p.pending===p.pending_buf_size)){B=1;break}p.gzindex<p.gzhead.name.length?B=p.gzhead.name.charCodeAt(p.gzindex++)&255:B=0,fe(p,B)}while(B!==0);p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),B===0&&(p.gzindex=0,p.status=we)}else p.status=we;if(p.status===we)if(p.gzhead.comment){E=p.pending;do{if(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),Ce(l),E=p.pending,p.pending===p.pending_buf_size)){B=1;break}p.gzindex<p.gzhead.comment.length?B=p.gzhead.comment.charCodeAt(p.gzindex++)&255:B=0,fe(p,B)}while(B!==0);p.gzhead.hcrc&&p.pending>E&&(l.adler=r(l.adler,p.pending_buf,p.pending-E,E)),B===0&&(p.status=ye)}else p.status=ye;if(p.status===ye&&(p.gzhead.hcrc?(p.pending+2>p.pending_buf_size&&Ce(l),p.pending+2<=p.pending_buf_size&&(fe(p,l.adler&255),fe(p,l.adler>>8&255),l.adler=0,p.status=ue)):p.status=ue),p.pending!==0){if(Ce(l),l.avail_out===0)return p.last_flush=-1,f}else if(l.avail_in===0&&$e(C)<=$e(P)&&C!==c)return _e(l,_);if(p.status===oe&&l.avail_in!==0)return _e(l,_);if(l.avail_in!==0||p.lookahead!==0||C!==a&&p.status!==oe){var V=p.strategy===v?wt(p,C):p.strategy===k?Bt(p,C):tt[p.level].func(p,C);if((V===Me||V===je)&&(p.status=oe),V===pe||V===Me)return l.avail_out===0&&(p.last_flush=-1),f;if(V===Re&&(C===s?e._tr_align(p):C!==u&&(e._tr_stored_block(p,0,0,!1),C===o&&(Ee(p.head),p.lookahead===0&&(p.strstart=0,p.block_start=0,p.insert=0))),Ce(l),l.avail_out===0))return p.last_flush=-1,f}return C!==c?f:p.wrap<=0?d:(p.wrap===2?(fe(p,l.adler&255),fe(p,l.adler>>8&255),fe(p,l.adler>>16&255),fe(p,l.adler>>24&255),fe(p,l.total_in&255),fe(p,l.total_in>>8&255),fe(p,l.total_in>>16&255),fe(p,l.total_in>>24&255)):(We(p,l.adler>>>16),We(p,l.adler&65535)),Ce(l),p.wrap>0&&(p.wrap=-p.wrap),p.pending!==0?f:d)}function Z(l){var C;return!l||!l.state?h:(C=l.state.status,C!==ie&&C!==re&&C!==le&&C!==we&&C!==ye&&C!==ue&&C!==oe?_e(l,h):(l.state=null,C===ue?_e(l,w):f))}function ne(l,C){var P=C.length,p,E,B,ee,Y,V,he,st;if(!l||!l.state||(p=l.state,ee=p.wrap,ee===2||ee===1&&p.status!==ie||p.lookahead))return h;for(ee===1&&(l.adler=t(l.adler,C,P,0)),p.wrap=0,P>=p.w_size&&(ee===0&&(Ee(p.head),p.strstart=0,p.block_start=0,p.insert=0),st=new i.Buf8(p.w_size),i.arraySet(st,C,P-p.w_size,p.w_size,0),C=st,P=p.w_size),Y=l.avail_in,V=l.next_in,he=l.input,l.avail_in=P,l.next_in=0,l.input=C,Xe(p);p.lookahead>=N;){E=p.strstart,B=p.lookahead-(N-1);do p.ins_h=(p.ins_h<<p.hash_shift^p.window[E+N-1])&p.hash_mask,p.prev[E&p.w_mask]=p.head[p.ins_h],p.head[p.ins_h]=E,E++;while(--B);p.strstart=E,p.lookahead=N-1,Xe(p)}return p.strstart+=p.lookahead,p.block_start=p.strstart,p.insert=p.lookahead,p.lookahead=0,p.match_length=p.prev_length=N-1,p.match_available=0,l.next_in=V,l.input=he,l.avail_in=Y,p.wrap=ee,f}return Je.deflateInit=z,Je.deflateInit2=$,Je.deflateReset=W,Je.deflateResetKeep=q,Je.deflateSetHeader=J,Je.deflate=m,Je.deflateEnd=Z,Je.deflateSetDictionary=ne,Je.deflateInfo="pako deflate (from Nodeca project)",Je}var Et={},Pn;function Ra(){if(Pn)return Et;Pn=1;var i=yt(),e=!0,t=!0;try{String.fromCharCode.apply(null,[0])}catch{e=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{t=!1}for(var r=new i.Buf8(256),n=0;n<256;n++)r[n]=n>=252?6:n>=248?5:n>=240?4:n>=224?3:n>=192?2:1;r[254]=r[254]=1,Et.string2buf=function(s){var o,c,u,f,d,h=s.length,w=0;for(f=0;f<h;f++)c=s.charCodeAt(f),(c&64512)===55296&&f+1<h&&(u=s.charCodeAt(f+1),(u&64512)===56320&&(c=65536+(c-55296<<10)+(u-56320),f++)),w+=c<128?1:c<2048?2:c<65536?3:4;for(o=new i.Buf8(w),d=0,f=0;d<w;f++)c=s.charCodeAt(f),(c&64512)===55296&&f+1<h&&(u=s.charCodeAt(f+1),(u&64512)===56320&&(c=65536+(c-55296<<10)+(u-56320),f++)),c<128?o[d++]=c:c<2048?(o[d++]=192|c>>>6,o[d++]=128|c&63):c<65536?(o[d++]=224|c>>>12,o[d++]=128|c>>>6&63,o[d++]=128|c&63):(o[d++]=240|c>>>18,o[d++]=128|c>>>12&63,o[d++]=128|c>>>6&63,o[d++]=128|c&63);return o};function a(s,o){if(o<65534&&(s.subarray&&t||!s.subarray&&e))return String.fromCharCode.apply(null,i.shrinkBuf(s,o));for(var c="",u=0;u<o;u++)c+=String.fromCharCode(s[u]);return c}return Et.buf2binstring=function(s){return a(s,s.length)},Et.binstring2buf=function(s){for(var o=new i.Buf8(s.length),c=0,u=o.length;c<u;c++)o[c]=s.charCodeAt(c);return o},Et.buf2string=function(s,o){var c,u,f,d,h=o||s.length,w=new Array(h*2);for(u=0,c=0;c<h;){if(f=s[c++],f<128){w[u++]=f;continue}if(d=r[f],d>4){w[u++]=65533,c+=d-1;continue}for(f&=d===2?31:d===3?15:7;d>1&&c<h;)f=f<<6|s[c++]&63,d--;if(d>1){w[u++]=65533;continue}f<65536?w[u++]=f:(f-=65536,w[u++]=55296|f>>10&1023,w[u++]=56320|f&1023)}return a(w,u)},Et.utf8border=function(s,o){var c;for(o=o||s.length,o>s.length&&(o=s.length),c=o-1;c>=0&&(s[c]&192)===128;)c--;return c<0||c===0?o:c+r[s[c]]>o?c:o},Et}var pi,Nn;function Ta(){if(Nn)return pi;Nn=1;function i(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}return pi=i,pi}var zn;function cc(){if(zn)return Dt;zn=1;var i=oc(),e=yt(),t=Ra(),r=Gi(),n=Ta(),a=Object.prototype.toString,s=0,o=4,c=0,u=1,f=2,d=-1,h=0,w=8;function _(k){if(!(this instanceof _))return new _(k);this.options=e.assign({level:d,method:w,chunkSize:16384,windowBits:15,memLevel:8,strategy:h,to:""},k||{});var S=this.options;S.raw&&S.windowBits>0?S.windowBits=-S.windowBits:S.gzip&&S.windowBits>0&&S.windowBits<16&&(S.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var O=i.deflateInit2(this.strm,S.level,S.method,S.windowBits,S.memLevel,S.strategy);if(O!==c)throw new Error(r[O]);if(S.header&&i.deflateSetHeader(this.strm,S.header),S.dictionary){var I;if(typeof S.dictionary=="string"?I=t.string2buf(S.dictionary):a.call(S.dictionary)==="[object ArrayBuffer]"?I=new Uint8Array(S.dictionary):I=S.dictionary,O=i.deflateSetDictionary(this.strm,I),O!==c)throw new Error(r[O]);this._dict_set=!0}}_.prototype.push=function(k,S){var O=this.strm,I=this.options.chunkSize,A,x;if(this.ended)return!1;x=S===~~S?S:S===!0?o:s,typeof k=="string"?O.input=t.string2buf(k):a.call(k)==="[object ArrayBuffer]"?O.input=new Uint8Array(k):O.input=k,O.next_in=0,O.avail_in=O.input.length;do{if(O.avail_out===0&&(O.output=new e.Buf8(I),O.next_out=0,O.avail_out=I),A=i.deflate(O,x),A!==u&&A!==c)return this.onEnd(A),this.ended=!0,!1;(O.avail_out===0||O.avail_in===0&&(x===o||x===f))&&(this.options.to==="string"?this.onData(t.buf2binstring(e.shrinkBuf(O.output,O.next_out))):this.onData(e.shrinkBuf(O.output,O.next_out)))}while((O.avail_in>0||O.avail_out===0)&&A!==u);return x===o?(A=i.deflateEnd(this.strm),this.onEnd(A),this.ended=!0,A===c):(x===f&&(this.onEnd(c),O.avail_out=0),!0)},_.prototype.onData=function(k){this.chunks.push(k)},_.prototype.onEnd=function(k){k===c&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=e.flattenChunks(this.chunks)),this.chunks=[],this.err=k,this.msg=this.strm.msg};function y(k,S){var O=new _(S);if(O.push(k,!0),O.err)throw O.msg||r[O.err];return O.result}function b(k,S){return S=S||{},S.raw=!0,y(k,S)}function v(k,S){return S=S||{},S.gzip=!0,y(k,S)}return Dt.Deflate=_,Dt.deflate=y,Dt.deflateRaw=b,Dt.gzip=v,Dt}var Pt={},Ye={},_i,Mn;function fc(){if(Mn)return _i;Mn=1;var i=30,e=12;return _i=function(r,n){var a,s,o,c,u,f,d,h,w,_,y,b,v,k,S,O,I,A,x,R,D,j,H,L,F;a=r.state,s=r.next_in,L=r.input,o=s+(r.avail_in-5),c=r.next_out,F=r.output,u=c-(n-r.avail_out),f=c+(r.avail_out-257),d=a.dmax,h=a.wsize,w=a.whave,_=a.wnext,y=a.window,b=a.hold,v=a.bits,k=a.lencode,S=a.distcode,O=(1<<a.lenbits)-1,I=(1<<a.distbits)-1;e:do{v<15&&(b+=L[s++]<<v,v+=8,b+=L[s++]<<v,v+=8),A=k[b&O];t:for(;;){if(x=A>>>24,b>>>=x,v-=x,x=A>>>16&255,x===0)F[c++]=A&65535;else if(x&16){R=A&65535,x&=15,x&&(v<x&&(b+=L[s++]<<v,v+=8),R+=b&(1<<x)-1,b>>>=x,v-=x),v<15&&(b+=L[s++]<<v,v+=8,b+=L[s++]<<v,v+=8),A=S[b&I];r:for(;;){if(x=A>>>24,b>>>=x,v-=x,x=A>>>16&255,x&16){if(D=A&65535,x&=15,v<x&&(b+=L[s++]<<v,v+=8,v<x&&(b+=L[s++]<<v,v+=8)),D+=b&(1<<x)-1,D>d){r.msg="invalid distance too far back",a.mode=i;break e}if(b>>>=x,v-=x,x=c-u,D>x){if(x=D-x,x>w&&a.sane){r.msg="invalid distance too far back",a.mode=i;break e}if(j=0,H=y,_===0){if(j+=h-x,x<R){R-=x;do F[c++]=y[j++];while(--x);j=c-D,H=F}}else if(_<x){if(j+=h+_-x,x-=_,x<R){R-=x;do F[c++]=y[j++];while(--x);if(j=0,_<R){x=_,R-=x;do F[c++]=y[j++];while(--x);j=c-D,H=F}}}else if(j+=_-x,x<R){R-=x;do F[c++]=y[j++];while(--x);j=c-D,H=F}for(;R>2;)F[c++]=H[j++],F[c++]=H[j++],F[c++]=H[j++],R-=3;R&&(F[c++]=H[j++],R>1&&(F[c++]=H[j++]))}else{j=c-D;do F[c++]=F[j++],F[c++]=F[j++],F[c++]=F[j++],R-=3;while(R>2);R&&(F[c++]=F[j++],R>1&&(F[c++]=F[j++]))}}else if((x&64)===0){A=S[(A&65535)+(b&(1<<x)-1)];continue r}else{r.msg="invalid distance code",a.mode=i;break e}break}}else if((x&64)===0){A=k[(A&65535)+(b&(1<<x)-1)];continue t}else if(x&32){a.mode=e;break e}else{r.msg="invalid literal/length code",a.mode=i;break e}break}}while(s<o&&c<f);R=v>>3,s-=R,v-=R<<3,b&=(1<<v)-1,r.next_in=s,r.next_out=c,r.avail_in=s<o?5+(o-s):5-(s-o),r.avail_out=c<f?257+(f-c):257-(c-f),a.hold=b,a.bits=v},_i}var gi,Fn;function lc(){if(Fn)return gi;Fn=1;var i=yt(),e=15,t=852,r=592,n=0,a=1,s=2,o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],c=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],u=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],f=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];return gi=function(h,w,_,y,b,v,k,S){var O=S.bits,I=0,A=0,x=0,R=0,D=0,j=0,H=0,L=0,F=0,K=0,ce,ge,N,U,X,ae=null,ie=0,re,le=new i.Buf16(e+1),we=new i.Buf16(e+1),ye=null,ue=0,oe,pe,Re;for(I=0;I<=e;I++)le[I]=0;for(A=0;A<y;A++)le[w[_+A]]++;for(D=O,R=e;R>=1&&le[R]===0;R--);if(D>R&&(D=R),R===0)return b[v++]=1<<24|64<<16|0,b[v++]=1<<24|64<<16|0,S.bits=1,0;for(x=1;x<R&&le[x]===0;x++);for(D<x&&(D=x),L=1,I=1;I<=e;I++)if(L<<=1,L-=le[I],L<0)return-1;if(L>0&&(h===n||R!==1))return-1;for(we[1]=0,I=1;I<e;I++)we[I+1]=we[I]+le[I];for(A=0;A<y;A++)w[_+A]!==0&&(k[we[w[_+A]]++]=A);if(h===n?(ae=ye=k,re=19):h===a?(ae=o,ie-=257,ye=c,ue-=257,re=256):(ae=u,ye=f,re=-1),K=0,A=0,I=x,X=v,j=D,H=0,N=-1,F=1<<D,U=F-1,h===a&&F>t||h===s&&F>r)return 1;for(;;){oe=I-H,k[A]<re?(pe=0,Re=k[A]):k[A]>re?(pe=ye[ue+k[A]],Re=ae[ie+k[A]]):(pe=96,Re=0),ce=1<<I-H,ge=1<<j,x=ge;do ge-=ce,b[X+(K>>H)+ge]=oe<<24|pe<<16|Re|0;while(ge!==0);for(ce=1<<I-1;K&ce;)ce>>=1;if(ce!==0?(K&=ce-1,K+=ce):K=0,A++,--le[I]===0){if(I===R)break;I=w[_+k[A]]}if(I>D&&(K&U)!==N){for(H===0&&(H=D),X+=x,j=I-H,L=1<<j;j+H<R&&(L-=le[j+H],!(L<=0));)j++,L<<=1;if(F+=1<<j,h===a&&F>t||h===s&&F>r)return 1;N=K&U,b[N]=D<<24|j<<16|X-v|0}}return K!==0&&(b[X+K]=I-H<<24|64<<16|0),S.bits=D,0},gi}var Un;function uc(){if(Un)return Ye;Un=1;var i=yt(),e=Ea(),t=Sa(),r=fc(),n=lc(),a=0,s=1,o=2,c=4,u=5,f=6,d=0,h=1,w=2,_=-2,y=-3,b=-4,v=-5,k=8,S=1,O=2,I=3,A=4,x=5,R=6,D=7,j=8,H=9,L=10,F=11,K=12,ce=13,ge=14,N=15,U=16,X=17,ae=18,ie=19,re=20,le=21,we=22,ye=23,ue=24,oe=25,pe=26,Re=27,Me=28,je=29,te=30,_e=31,$e=32,Ee=852,Ce=592,ve=15,fe=ve;function We($){return($>>>24&255)+($>>>8&65280)+(($&65280)<<8)+(($&255)<<24)}function It(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new i.Buf16(320),this.work=new i.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function ht($){var z;return!$||!$.state?_:(z=$.state,$.total_in=$.total_out=z.total=0,$.msg="",z.wrap&&($.adler=z.wrap&1),z.mode=S,z.last=0,z.havedict=0,z.dmax=32768,z.head=null,z.hold=0,z.bits=0,z.lencode=z.lendyn=new i.Buf32(Ee),z.distcode=z.distdyn=new i.Buf32(Ce),z.sane=1,z.back=-1,d)}function Xe($){var z;return!$||!$.state?_:(z=$.state,z.wsize=0,z.whave=0,z.wnext=0,ht($))}function jt($,z){var m,Z;return!$||!$.state||(Z=$.state,z<0?(m=0,z=-z):(m=(z>>4)+1,z<48&&(z&=15)),z&&(z<8||z>15))?_:(Z.window!==null&&Z.wbits!==z&&(Z.window=null),Z.wrap=m,Z.wbits=z,Xe($))}function dt($,z){var m,Z;return $?(Z=new It,$.state=Z,Z.window=null,m=jt($,z),m!==d&&($.state=null),m):_}function Ve($){return dt($,fe)}var Bt=!0,wt,Pe;function tt($){if(Bt){var z;for(wt=new i.Buf32(512),Pe=new i.Buf32(32),z=0;z<144;)$.lens[z++]=8;for(;z<256;)$.lens[z++]=9;for(;z<280;)$.lens[z++]=7;for(;z<288;)$.lens[z++]=8;for(n(s,$.lens,0,288,wt,0,$.work,{bits:9}),z=0;z<32;)$.lens[z++]=5;n(o,$.lens,0,32,Pe,0,$.work,{bits:5}),Bt=!1}$.lencode=wt,$.lenbits=9,$.distcode=Pe,$.distbits=5}function Ct($,z,m,Z){var ne,l=$.state;return l.window===null&&(l.wsize=1<<l.wbits,l.wnext=0,l.whave=0,l.window=new i.Buf8(l.wsize)),Z>=l.wsize?(i.arraySet(l.window,z,m-l.wsize,l.wsize,0),l.wnext=0,l.whave=l.wsize):(ne=l.wsize-l.wnext,ne>Z&&(ne=Z),i.arraySet(l.window,z,m-Z,ne,l.wnext),Z-=ne,Z?(i.arraySet(l.window,z,m-Z,Z,0),l.wnext=Z,l.whave=l.wsize):(l.wnext+=ne,l.wnext===l.wsize&&(l.wnext=0),l.whave<l.wsize&&(l.whave+=ne))),0}function g($,z){var m,Z,ne,l,C,P,p,E,B,ee,Y,V,he,st,Se=0,me,Ie,Ne,Le,kr,xr,Ae,Ke,De=new i.Buf8(4),ot,rt,an=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!$||!$.state||!$.output||!$.input&&$.avail_in!==0)return _;m=$.state,m.mode===K&&(m.mode=ce),C=$.next_out,ne=$.output,p=$.avail_out,l=$.next_in,Z=$.input,P=$.avail_in,E=m.hold,B=m.bits,ee=P,Y=p,Ke=d;e:for(;;)switch(m.mode){case S:if(m.wrap===0){m.mode=ce;break}for(;B<16;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(m.wrap&2&&E===35615){m.check=0,De[0]=E&255,De[1]=E>>>8&255,m.check=t(m.check,De,2,0),E=0,B=0,m.mode=O;break}if(m.flags=0,m.head&&(m.head.done=!1),!(m.wrap&1)||(((E&255)<<8)+(E>>8))%31){$.msg="incorrect header check",m.mode=te;break}if((E&15)!==k){$.msg="unknown compression method",m.mode=te;break}if(E>>>=4,B-=4,Ae=(E&15)+8,m.wbits===0)m.wbits=Ae;else if(Ae>m.wbits){$.msg="invalid window size",m.mode=te;break}m.dmax=1<<Ae,$.adler=m.check=1,m.mode=E&512?L:K,E=0,B=0;break;case O:for(;B<16;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(m.flags=E,(m.flags&255)!==k){$.msg="unknown compression method",m.mode=te;break}if(m.flags&57344){$.msg="unknown header flags set",m.mode=te;break}m.head&&(m.head.text=E>>8&1),m.flags&512&&(De[0]=E&255,De[1]=E>>>8&255,m.check=t(m.check,De,2,0)),E=0,B=0,m.mode=I;case I:for(;B<32;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.head&&(m.head.time=E),m.flags&512&&(De[0]=E&255,De[1]=E>>>8&255,De[2]=E>>>16&255,De[3]=E>>>24&255,m.check=t(m.check,De,4,0)),E=0,B=0,m.mode=A;case A:for(;B<16;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.head&&(m.head.xflags=E&255,m.head.os=E>>8),m.flags&512&&(De[0]=E&255,De[1]=E>>>8&255,m.check=t(m.check,De,2,0)),E=0,B=0,m.mode=x;case x:if(m.flags&1024){for(;B<16;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.length=E,m.head&&(m.head.extra_len=E),m.flags&512&&(De[0]=E&255,De[1]=E>>>8&255,m.check=t(m.check,De,2,0)),E=0,B=0}else m.head&&(m.head.extra=null);m.mode=R;case R:if(m.flags&1024&&(V=m.length,V>P&&(V=P),V&&(m.head&&(Ae=m.head.extra_len-m.length,m.head.extra||(m.head.extra=new Array(m.head.extra_len)),i.arraySet(m.head.extra,Z,l,V,Ae)),m.flags&512&&(m.check=t(m.check,Z,V,l)),P-=V,l+=V,m.length-=V),m.length))break e;m.length=0,m.mode=D;case D:if(m.flags&2048){if(P===0)break e;V=0;do Ae=Z[l+V++],m.head&&Ae&&m.length<65536&&(m.head.name+=String.fromCharCode(Ae));while(Ae&&V<P);if(m.flags&512&&(m.check=t(m.check,Z,V,l)),P-=V,l+=V,Ae)break e}else m.head&&(m.head.name=null);m.length=0,m.mode=j;case j:if(m.flags&4096){if(P===0)break e;V=0;do Ae=Z[l+V++],m.head&&Ae&&m.length<65536&&(m.head.comment+=String.fromCharCode(Ae));while(Ae&&V<P);if(m.flags&512&&(m.check=t(m.check,Z,V,l)),P-=V,l+=V,Ae)break e}else m.head&&(m.head.comment=null);m.mode=H;case H:if(m.flags&512){for(;B<16;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(E!==(m.check&65535)){$.msg="header crc mismatch",m.mode=te;break}E=0,B=0}m.head&&(m.head.hcrc=m.flags>>9&1,m.head.done=!0),$.adler=m.check=0,m.mode=K;break;case L:for(;B<32;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}$.adler=m.check=We(E),E=0,B=0,m.mode=F;case F:if(m.havedict===0)return $.next_out=C,$.avail_out=p,$.next_in=l,$.avail_in=P,m.hold=E,m.bits=B,w;$.adler=m.check=1,m.mode=K;case K:if(z===u||z===f)break e;case ce:if(m.last){E>>>=B&7,B-=B&7,m.mode=Re;break}for(;B<3;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}switch(m.last=E&1,E>>>=1,B-=1,E&3){case 0:m.mode=ge;break;case 1:if(tt(m),m.mode=re,z===f){E>>>=2,B-=2;break e}break;case 2:m.mode=X;break;case 3:$.msg="invalid block type",m.mode=te}E>>>=2,B-=2;break;case ge:for(E>>>=B&7,B-=B&7;B<32;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if((E&65535)!==(E>>>16^65535)){$.msg="invalid stored block lengths",m.mode=te;break}if(m.length=E&65535,E=0,B=0,m.mode=N,z===f)break e;case N:m.mode=U;case U:if(V=m.length,V){if(V>P&&(V=P),V>p&&(V=p),V===0)break e;i.arraySet(ne,Z,l,V,C),P-=V,l+=V,p-=V,C+=V,m.length-=V;break}m.mode=K;break;case X:for(;B<14;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(m.nlen=(E&31)+257,E>>>=5,B-=5,m.ndist=(E&31)+1,E>>>=5,B-=5,m.ncode=(E&15)+4,E>>>=4,B-=4,m.nlen>286||m.ndist>30){$.msg="too many length or distance symbols",m.mode=te;break}m.have=0,m.mode=ae;case ae:for(;m.have<m.ncode;){for(;B<3;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.lens[an[m.have++]]=E&7,E>>>=3,B-=3}for(;m.have<19;)m.lens[an[m.have++]]=0;if(m.lencode=m.lendyn,m.lenbits=7,ot={bits:m.lenbits},Ke=n(a,m.lens,0,19,m.lencode,0,m.work,ot),m.lenbits=ot.bits,Ke){$.msg="invalid code lengths set",m.mode=te;break}m.have=0,m.mode=ie;case ie:for(;m.have<m.nlen+m.ndist;){for(;Se=m.lencode[E&(1<<m.lenbits)-1],me=Se>>>24,Ie=Se>>>16&255,Ne=Se&65535,!(me<=B);){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(Ne<16)E>>>=me,B-=me,m.lens[m.have++]=Ne;else{if(Ne===16){for(rt=me+2;B<rt;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(E>>>=me,B-=me,m.have===0){$.msg="invalid bit length repeat",m.mode=te;break}Ae=m.lens[m.have-1],V=3+(E&3),E>>>=2,B-=2}else if(Ne===17){for(rt=me+3;B<rt;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}E>>>=me,B-=me,Ae=0,V=3+(E&7),E>>>=3,B-=3}else{for(rt=me+7;B<rt;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}E>>>=me,B-=me,Ae=0,V=11+(E&127),E>>>=7,B-=7}if(m.have+V>m.nlen+m.ndist){$.msg="invalid bit length repeat",m.mode=te;break}for(;V--;)m.lens[m.have++]=Ae}}if(m.mode===te)break;if(m.lens[256]===0){$.msg="invalid code -- missing end-of-block",m.mode=te;break}if(m.lenbits=9,ot={bits:m.lenbits},Ke=n(s,m.lens,0,m.nlen,m.lencode,0,m.work,ot),m.lenbits=ot.bits,Ke){$.msg="invalid literal/lengths set",m.mode=te;break}if(m.distbits=6,m.distcode=m.distdyn,ot={bits:m.distbits},Ke=n(o,m.lens,m.nlen,m.ndist,m.distcode,0,m.work,ot),m.distbits=ot.bits,Ke){$.msg="invalid distances set",m.mode=te;break}if(m.mode=re,z===f)break e;case re:m.mode=le;case le:if(P>=6&&p>=258){$.next_out=C,$.avail_out=p,$.next_in=l,$.avail_in=P,m.hold=E,m.bits=B,r($,Y),C=$.next_out,ne=$.output,p=$.avail_out,l=$.next_in,Z=$.input,P=$.avail_in,E=m.hold,B=m.bits,m.mode===K&&(m.back=-1);break}for(m.back=0;Se=m.lencode[E&(1<<m.lenbits)-1],me=Se>>>24,Ie=Se>>>16&255,Ne=Se&65535,!(me<=B);){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(Ie&&(Ie&240)===0){for(Le=me,kr=Ie,xr=Ne;Se=m.lencode[xr+((E&(1<<Le+kr)-1)>>Le)],me=Se>>>24,Ie=Se>>>16&255,Ne=Se&65535,!(Le+me<=B);){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}E>>>=Le,B-=Le,m.back+=Le}if(E>>>=me,B-=me,m.back+=me,m.length=Ne,Ie===0){m.mode=pe;break}if(Ie&32){m.back=-1,m.mode=K;break}if(Ie&64){$.msg="invalid literal/length code",m.mode=te;break}m.extra=Ie&15,m.mode=we;case we:if(m.extra){for(rt=m.extra;B<rt;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.length+=E&(1<<m.extra)-1,E>>>=m.extra,B-=m.extra,m.back+=m.extra}m.was=m.length,m.mode=ye;case ye:for(;Se=m.distcode[E&(1<<m.distbits)-1],me=Se>>>24,Ie=Se>>>16&255,Ne=Se&65535,!(me<=B);){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if((Ie&240)===0){for(Le=me,kr=Ie,xr=Ne;Se=m.distcode[xr+((E&(1<<Le+kr)-1)>>Le)],me=Se>>>24,Ie=Se>>>16&255,Ne=Se&65535,!(Le+me<=B);){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}E>>>=Le,B-=Le,m.back+=Le}if(E>>>=me,B-=me,m.back+=me,Ie&64){$.msg="invalid distance code",m.mode=te;break}m.offset=Ne,m.extra=Ie&15,m.mode=ue;case ue:if(m.extra){for(rt=m.extra;B<rt;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}m.offset+=E&(1<<m.extra)-1,E>>>=m.extra,B-=m.extra,m.back+=m.extra}if(m.offset>m.dmax){$.msg="invalid distance too far back",m.mode=te;break}m.mode=oe;case oe:if(p===0)break e;if(V=Y-p,m.offset>V){if(V=m.offset-V,V>m.whave&&m.sane){$.msg="invalid distance too far back",m.mode=te;break}V>m.wnext?(V-=m.wnext,he=m.wsize-V):he=m.wnext-V,V>m.length&&(V=m.length),st=m.window}else st=ne,he=C-m.offset,V=m.length;V>p&&(V=p),p-=V,m.length-=V;do ne[C++]=st[he++];while(--V);m.length===0&&(m.mode=le);break;case pe:if(p===0)break e;ne[C++]=m.length,p--,m.mode=le;break;case Re:if(m.wrap){for(;B<32;){if(P===0)break e;P--,E|=Z[l++]<<B,B+=8}if(Y-=p,$.total_out+=Y,m.total+=Y,Y&&($.adler=m.check=m.flags?t(m.check,ne,Y,C-Y):e(m.check,ne,Y,C-Y)),Y=p,(m.flags?E:We(E))!==m.check){$.msg="incorrect data check",m.mode=te;break}E=0,B=0}m.mode=Me;case Me:if(m.wrap&&m.flags){for(;B<32;){if(P===0)break e;P--,E+=Z[l++]<<B,B+=8}if(E!==(m.total&4294967295)){$.msg="incorrect length check",m.mode=te;break}E=0,B=0}m.mode=je;case je:Ke=h;break e;case te:Ke=y;break e;case _e:return b;case $e:default:return _}return $.next_out=C,$.avail_out=p,$.next_in=l,$.avail_in=P,m.hold=E,m.bits=B,(m.wsize||Y!==$.avail_out&&m.mode<te&&(m.mode<Re||z!==c))&&Ct($,$.output,$.next_out,Y-$.avail_out),ee-=$.avail_in,Y-=$.avail_out,$.total_in+=ee,$.total_out+=Y,m.total+=Y,m.wrap&&Y&&($.adler=m.check=m.flags?t(m.check,ne,Y,$.next_out-Y):e(m.check,ne,Y,$.next_out-Y)),$.data_type=m.bits+(m.last?64:0)+(m.mode===K?128:0)+(m.mode===re||m.mode===N?256:0),(ee===0&&Y===0||z===c)&&Ke===d&&(Ke=v),Ke}function q($){if(!$||!$.state)return _;var z=$.state;return z.window&&(z.window=null),$.state=null,d}function W($,z){var m;return!$||!$.state||(m=$.state,(m.wrap&2)===0)?_:(m.head=z,z.done=!1,d)}function J($,z){var m=z.length,Z,ne,l;return!$||!$.state||(Z=$.state,Z.wrap!==0&&Z.mode!==F)?_:Z.mode===F&&(ne=1,ne=e(ne,z,m,0),ne!==Z.check)?y:(l=Ct($,z,m,m),l?(Z.mode=_e,b):(Z.havedict=1,d))}return Ye.inflateReset=Xe,Ye.inflateReset2=jt,Ye.inflateResetKeep=ht,Ye.inflateInit=Ve,Ye.inflateInit2=dt,Ye.inflate=g,Ye.inflateEnd=q,Ye.inflateGetHeader=W,Ye.inflateSetDictionary=J,Ye.inflateInfo="pako inflate (from Nodeca project)",Ye}var vi,Ln;function $a(){return Ln||(Ln=1,vi={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}),vi}var bi,Hn;function hc(){if(Hn)return bi;Hn=1;function i(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}return bi=i,bi}var qn;function dc(){if(qn)return Pt;qn=1;var i=uc(),e=yt(),t=Ra(),r=$a(),n=Gi(),a=Ta(),s=hc(),o=Object.prototype.toString;function c(d){if(!(this instanceof c))return new c(d);this.options=e.assign({chunkSize:16384,windowBits:0,to:""},d||{});var h=this.options;h.raw&&h.windowBits>=0&&h.windowBits<16&&(h.windowBits=-h.windowBits,h.windowBits===0&&(h.windowBits=-15)),h.windowBits>=0&&h.windowBits<16&&!(d&&d.windowBits)&&(h.windowBits+=32),h.windowBits>15&&h.windowBits<48&&(h.windowBits&15)===0&&(h.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new a,this.strm.avail_out=0;var w=i.inflateInit2(this.strm,h.windowBits);if(w!==r.Z_OK)throw new Error(n[w]);if(this.header=new s,i.inflateGetHeader(this.strm,this.header),h.dictionary&&(typeof h.dictionary=="string"?h.dictionary=t.string2buf(h.dictionary):o.call(h.dictionary)==="[object ArrayBuffer]"&&(h.dictionary=new Uint8Array(h.dictionary)),h.raw&&(w=i.inflateSetDictionary(this.strm,h.dictionary),w!==r.Z_OK)))throw new Error(n[w])}c.prototype.push=function(d,h){var w=this.strm,_=this.options.chunkSize,y=this.options.dictionary,b,v,k,S,O,I=!1;if(this.ended)return!1;v=h===~~h?h:h===!0?r.Z_FINISH:r.Z_NO_FLUSH,typeof d=="string"?w.input=t.binstring2buf(d):o.call(d)==="[object ArrayBuffer]"?w.input=new Uint8Array(d):w.input=d,w.next_in=0,w.avail_in=w.input.length;do{if(w.avail_out===0&&(w.output=new e.Buf8(_),w.next_out=0,w.avail_out=_),b=i.inflate(w,r.Z_NO_FLUSH),b===r.Z_NEED_DICT&&y&&(b=i.inflateSetDictionary(this.strm,y)),b===r.Z_BUF_ERROR&&I===!0&&(b=r.Z_OK,I=!1),b!==r.Z_STREAM_END&&b!==r.Z_OK)return this.onEnd(b),this.ended=!0,!1;w.next_out&&(w.avail_out===0||b===r.Z_STREAM_END||w.avail_in===0&&(v===r.Z_FINISH||v===r.Z_SYNC_FLUSH))&&(this.options.to==="string"?(k=t.utf8border(w.output,w.next_out),S=w.next_out-k,O=t.buf2string(w.output,k),w.next_out=S,w.avail_out=_-S,S&&e.arraySet(w.output,w.output,k,S,0),this.onData(O)):this.onData(e.shrinkBuf(w.output,w.next_out))),w.avail_in===0&&w.avail_out===0&&(I=!0)}while((w.avail_in>0||w.avail_out===0)&&b!==r.Z_STREAM_END);return b===r.Z_STREAM_END&&(v=r.Z_FINISH),v===r.Z_FINISH?(b=i.inflateEnd(this.strm),this.onEnd(b),this.ended=!0,b===r.Z_OK):(v===r.Z_SYNC_FLUSH&&(this.onEnd(r.Z_OK),w.avail_out=0),!0)},c.prototype.onData=function(d){this.chunks.push(d)},c.prototype.onEnd=function(d){d===r.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=e.flattenChunks(this.chunks)),this.chunks=[],this.err=d,this.msg=this.strm.msg};function u(d,h){var w=new c(h);if(w.push(d,!0),w.err)throw w.msg||n[w.err];return w.result}function f(d,h){return h=h||{},h.raw=!0,u(d,h)}return Pt.Inflate=c,Pt.inflate=u,Pt.inflateRaw=f,Pt.ungzip=u,Pt}var yi,Zn;function wc(){if(Zn)return yi;Zn=1;var i=yt().assign,e=cc(),t=dc(),r=$a(),n={};return i(n,e,t,r),yi=n,yi}var mc=wc();const Wi=ut(mc);var ki,Gn;function pc(){if(Gn)return ki;Gn=1;const i=(e,t)=>function(...r){const n=t.promiseModule;return new n((a,s)=>{t.multiArgs?r.push((...o)=>{t.errorFirst?o[0]?s(o):(o.shift(),a(o)):a(o)}):t.errorFirst?r.push((o,c)=>{o?s(o):a(c)}):r.push(a),e.apply(this,r)})};return ki=(e,t)=>{t=Object.assign({exclude:[/.+(Sync|Stream)$/],errorFirst:!0,promiseModule:Promise},t);const r=typeof e;if(!(e!==null&&(r==="object"||r==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e===null?"null":r}\``);const n=s=>{const o=c=>typeof c=="string"?s===c:c.test(s);return t.include?t.include.some(o):!t.exclude.some(o)};let a;r==="function"?a=function(...s){return t.excludeMain?e(...s):i(e,t).apply(this,s)}:a=Object.create(Object.getPrototypeOf(e));for(const s in e){const o=e[s];a[s]=typeof o=="function"&&n(s)?i(o,t):o}return a},ki}var _c=pc();const xi=ut(_c);var Ei,Wn;function gc(){if(Wn)return Ei;Wn=1;var i={};function e(N){return Array.isArray(N)?N:[N]}const t="",r=" ",n="\\",a=/^\s+$/,s=/(?:[^\\]|^)\\$/,o=/^\\!/,c=/^\\#/,u=/\r?\n/g,f=/^\.*\/|^\.+$/,d="/";let h="node-ignore";typeof Symbol<"u"&&(h=Symbol.for("node-ignore"));const w=h,_=(N,U,X)=>Object.defineProperty(N,U,{value:X}),y=/([0-z])-([0-z])/g,b=()=>!1,v=N=>N.replace(y,(U,X,ae)=>X.charCodeAt(0)<=ae.charCodeAt(0)?U:t),k=N=>{const{length:U}=N;return N.slice(0,U-U%2)},S=[[/^\uFEFF/,()=>t],[/((?:\\\\)*?)(\\?\s+)$/,(N,U,X)=>U+(X.indexOf("\\")===0?r:t)],[/(\\+?)\s/g,(N,U)=>{const{length:X}=U;return U.slice(0,X-X%2)+r}],[/[\\$.|*+(){^]/g,N=>`\\${N}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(N,U,X)=>U+6<X.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)(\\\*)+(?=.+)/g,(N,U,X)=>{const ae=X.replace(/\\\*/g,"[^\\/]*");return U+ae}],[/\\\\\\(?=[$.|*+(){^])/g,()=>n],[/\\\\/g,()=>n],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(N,U,X,ae,ie)=>U===n?`\\[${X}${k(ae)}${ie}`:ie==="]"&&ae.length%2===0?`[${v(X)}${ae}]`:"[]"],[/(?:[^*])$/,N=>/\/$/.test(N)?`${N}$`:`${N}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(N,U)=>`${U?`${U}[^/]+`:"[^/]*"}(?=$|\\/$)`]],O=Object.create(null),I=(N,U)=>{let X=O[N];return X||(X=S.reduce((ae,[ie,re])=>ae.replace(ie,re.bind(N)),N),O[N]=X),U?new RegExp(X,"i"):new RegExp(X)},A=N=>typeof N=="string",x=N=>N&&A(N)&&!a.test(N)&&!s.test(N)&&N.indexOf("#")!==0,R=N=>N.split(u);class D{constructor(U,X,ae,ie){this.origin=U,this.pattern=X,this.negative=ae,this.regex=ie}}const j=(N,U)=>{const X=N;let ae=!1;N.indexOf("!")===0&&(ae=!0,N=N.substr(1)),N=N.replace(o,"!").replace(c,"#");const ie=I(N,U);return new D(X,N,ae,ie)},H=(N,U)=>{throw new U(N)},L=(N,U,X)=>A(N)?N?L.isNotRelative(N)?X(`path should be a \`path.relative()\`d string, but got "${U}"`,RangeError):!0:X("path must not be empty",TypeError):X(`path must be a string, but got \`${U}\``,TypeError),F=N=>f.test(N);L.isNotRelative=F,L.convert=N=>N;class K{constructor({ignorecase:U=!0,ignoreCase:X=U,allowRelativePaths:ae=!1}={}){_(this,w,!0),this._rules=[],this._ignoreCase=X,this._allowRelativePaths=ae,this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(U){if(U&&U[w]){this._rules=this._rules.concat(U._rules),this._added=!0;return}if(x(U)){const X=j(U,this._ignoreCase);this._added=!0,this._rules.push(X)}}add(U){return this._added=!1,e(A(U)?R(U):U).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(U){return this.add(U)}_testOne(U,X){let ae=!1,ie=!1;return this._rules.forEach(re=>{const{negative:le}=re;if(ie===le&&ae!==ie||le&&!ae&&!ie&&!X)return;re.regex.test(U)&&(ae=!le,ie=le)}),{ignored:ae,unignored:ie}}_test(U,X,ae,ie){const re=U&&L.convert(U);return L(re,U,this._allowRelativePaths?b:H),this._t(re,X,ae,ie)}_t(U,X,ae,ie){if(U in X)return X[U];if(ie||(ie=U.split(d)),ie.pop(),!ie.length)return X[U]=this._testOne(U,ae);const re=this._t(ie.join(d)+d,X,ae,ie);return X[U]=re.ignored?re:this._testOne(U,ae)}ignores(U){return this._test(U,this._ignoreCache,!1).ignored}createFilter(){return U=>!this.ignores(U)}filter(U){return e(U).filter(this.createFilter())}test(U){return this._test(U,this._testCache,!0)}}const ce=N=>new K(N),ge=N=>L(N&&L.convert(N),N,b);if(ce.isPathValid=ge,ce.default=ce,Ei=ce,typeof process<"u"&&(i&&i.IGNORE_TEST_WIN32||process.platform==="win32")){const N=X=>/^\\\\\?\\/.test(X)||/["<>|\u0000-\u001F]+/u.test(X)?X:X.replace(/\\/g,"/");L.convert=N;const U=/^[a-z]:\//i;L.isNotRelative=X=>U.test(X)||F(X)}return Ei}var vc=gc();const bc=ut(vc);var Si,Xn;function yc(){if(Xn)return Si;Xn=1;function i(r){return r.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function e(r,n,a){return n=n instanceof RegExp?n:new RegExp(i(n),"g"),r.replace(n,a)}var t={clean:function(n){if(typeof n!="string")throw new Error("Expected a string, received: "+n);return n=e(n,"./","/"),n=e(n,"..","."),n=e(n," ","-"),n=e(n,/^[~^:?*\\\-]/g,""),n=e(n,/[~^:?*\\]/g,"-"),n=e(n,/[~^:?*\\\-]$/g,""),n=e(n,"@{","-"),n=e(n,/\.$/g,""),n=e(n,/\/$/g,""),n=e(n,/\.lock$/g,""),n}};return Si=t,Si}var kc=yc();const at=ut(kc);var Ri,Kn;function xc(){return Kn||(Kn=1,Ri=function(i,e){var t=i,r=e,n=t.length,a=r.length,s=!1,o=null,c=n+1,u=[],f=[],d=[],h="",w=-1,_=0,y=1,b,v,k=function(){n>=a&&(b=t,v=n,t=r,r=b,n=a,a=v,s=!0,c=n+1)},S=function(x,R,D){return{x,y:R,k:D}},O=function(x,R){return{elem:x,t:R}},I=function(x,R,D){var j,H,L;for(R>D?j=u[x-1+c]:j=u[x+1+c],L=Math.max(R,D),H=L-x;H<n&&L<a&&t[H]===r[L];)++H,++L;return u[x+c]=f.length,f[f.length]=new S(H,L,j),L},A=function(x){var R,D,j;for(R=D=0,j=x.length-1;j>=0;--j)for(;R<x[j].x||D<x[j].y;)x[j].y-x[j].x>D-R?(s?d[d.length]=new O(r[D],w):d[d.length]=new O(r[D],y),++D):x[j].y-x[j].x<D-R?(s?d[d.length]=new O(t[R],y):d[d.length]=new O(t[R],w),++R):(d[d.length]=new O(t[R],_),h+=t[R],++R,++D)};return k(),{SES_DELETE:-1,SES_COMMON:0,SES_ADD:1,editdistance:function(){return o},getlcs:function(){return h},getses:function(){return d},compose:function(){var x,R,D,j,H,L,F,K;for(x=a-n,R=n+a+3,D={},F=0;F<R;++F)D[F]=-1,u[F]=-1;j=-1;do{for(++j,K=-j;K<=x-1;++K)D[K+c]=I(K,D[K-1+c]+1,D[K+1+c]);for(K=x+j;K>=x+1;--K)D[K+c]=I(K,D[K-1+c]+1,D[K+1+c]);D[x+c]=I(x,D[x-1+c]+1,D[x+1+c])}while(D[x+c]!==a);for(o=x+2*j,H=u[x+c],L=[];H!==-1;)L[L.length]=new S(f[H].x,f[H].y,null),H=f[H].k;A(L)}}}),Ri}var Ti,Yn;function Ec(){if(Yn)return Ti;Yn=1;var i=xc();function e(a,s){var o=new i(a,s);o.compose();for(var c=o.getses(),u,f,d=a.length-1,h=s.length-1,w=c.length-1;w>=0;--w)c[w].t===o.SES_COMMON?(f?(f.chain={file1index:d,file2index:h,chain:null},f=f.chain):(u={file1index:d,file2index:h,chain:null},f=u),d--,h--):c[w].t===o.SES_DELETE?d--:c[w].t===o.SES_ADD&&h--;var _={file1index:-1,file2index:-1,chain:null};return f?(f.chain=_,u):_}function t(a,s){for(var o=[],c=a.length,u=s.length,f=e(a,s);f!==null;f=f.chain){var d=c-f.file1index-1,h=u-f.file2index-1;c=f.file1index,u=f.file2index,(d||h)&&o.push({file1:[c+1,d],file2:[u+1,h]})}return o.reverse(),o}function r(a,s,o){var c,u=t(s,a),f=t(s,o),d=[];function h(U,X){d.push([U.file1[0],X,U.file1[1],U.file2[0],U.file2[1]])}for(c=0;c<u.length;c++)h(u[c],0);for(c=0;c<f.length;c++)h(f[c],2);d.sort(function(U,X){return U[0]-X[0]});var w=[],_=0;function y(U){U>_&&(w.push([1,_,U-_]),_=U)}for(var b=0;b<d.length;b++){for(var v=b,k=d[b],S=k[0],O=S+k[2];b<d.length-1;){var I=d[b+1],A=I[0];if(A>O)break;O=Math.max(O,A+I[2]),b++}if(y(S),v==b)k[4]>0&&w.push([k[1],k[3],k[4]]);else{var x={0:[a.length,-1,s.length,-1],2:[o.length,-1,s.length,-1]};for(c=v;c<=b;c++){k=d[c];var R=k[1],D=x[R],j=k[0],H=j+k[2],L=k[3],F=L+k[4];D[0]=Math.min(L,D[0]),D[1]=Math.max(F,D[1]),D[2]=Math.min(j,D[2]),D[3]=Math.max(H,D[3])}var K=x[0][0]+(S-x[0][2]),ce=x[0][1]+(O-x[0][3]),ge=x[2][0]+(S-x[2][2]),N=x[2][1]+(O-x[2][3]);w.push([-1,K,ce-K,S,O-S,ge,N-ge])}_=O}return y(s.length),w}function n(a,s,o){var c=[],u=[a,s,o],f=r(a,s,o),d=[];function h(){d.length&&c.push({ok:d}),d=[]}function w(k){for(var S=0;S<k.length;S++)d.push(k[S])}function _(k){if(k[2]!=k[6])return!0;for(var S=k[1],O=k[5],I=0;I<k[2];I++)if(a[I+S]!=o[I+O])return!0;return!1}for(var y=0;y<f.length;y++){var b=f[y],v=b[0];v==-1?_(b)?(h(),c.push({conflict:{a:a.slice(b[1],b[1]+b[2]),aIndex:b[1],o:s.slice(b[3],b[3]+b[4]),oIndex:b[3],b:o.slice(b[5],b[5]+b[6]),bIndex:b[5]}})):w(u[0].slice(b[1],b[1]+b[2])):w(u[v].slice(b[1],b[1]+b[2]))}return h(),c}return Ti=n,Ti}var Sc=Ec();const Rc=ut(Sc);class de extends Error{constructor(e){super(e),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(e){const t=new de(e.message);return t.code=e.code,t.data=e.data,t.caller=e.caller,t.stack=e.stack,t}get isIsomorphicGitError(){return!0}}class nr extends de{constructor(e){super(`Modifying the index is not possible because you have unmerged files: ${e.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=nr.code,this.data={filepaths:e}}}nr.code="UnmergedPathsError";class se extends de{constructor(e){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${e}`),this.code=this.name=se.code,this.data={message:e}}}se.code="InternalError";class Gt extends de{constructor(e){super(`The filepath "${e}" contains unsafe character sequences`),this.code=this.name=Gt.code,this.data={filepath:e}}}Gt.code="UnsafeFilepathError";class nt{constructor(e){this.buffer=e,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(e){this._start=e}slice(e){const t=this.buffer.slice(this._start,this._start+e);return this._start+=e,t}toString(e,t){const r=this.buffer.toString(e,this._start,this._start+t);return this._start+=t,r}write(e,t,r){const n=this.buffer.write(e,this._start,t,r);return this._start+=t,n}copy(e,t,r){const n=e.copy(this.buffer,this._start,t,r);return this._start+=n,n}readUInt8(){const e=this.buffer.readUInt8(this._start);return this._start+=1,e}writeUInt8(e){const t=this.buffer.writeUInt8(e,this._start);return this._start+=1,t}readUInt16BE(){const e=this.buffer.readUInt16BE(this._start);return this._start+=2,e}writeUInt16BE(e){const t=this.buffer.writeUInt16BE(e,this._start);return this._start+=2,t}readUInt32BE(){const e=this.buffer.readUInt32BE(this._start);return this._start+=4,e}writeUInt32BE(e){const t=this.buffer.writeUInt32BE(e,this._start);return this._start+=4,t}}function Mr(i,e){return-(i<e)||+(i>e)}function Aa(i,e){return Mr(i.path,e.path)}function Oa(i){let e=i>0?i>>12:0;e!==4&&e!==8&&e!==10&&e!==14&&(e=8);let t=i&511;return t&73?t=493:t=420,e!==8&&(t=0),(e<<12)+t}const it=2**32;function Vn(i,e,t,r){if(i!==void 0&&e!==void 0)return[i,e];t===void 0&&(t=r.valueOf());const n=Math.floor(t/1e3),a=(t-n*1e3)*1e6;return[n,a]}function Nt(i){const[e,t]=Vn(i.ctimeSeconds,i.ctimeNanoseconds,i.ctimeMs,i.ctime),[r,n]=Vn(i.mtimeSeconds,i.mtimeNanoseconds,i.mtimeMs,i.mtime);return{ctimeSeconds:e%it,ctimeNanoseconds:t%it,mtimeSeconds:r%it,mtimeNanoseconds:n%it,dev:i.dev%it,ino:i.ino%it,mode:Oa(i.mode%it),uid:i.uid%it,gid:i.gid%it,size:i.size>-1?i.size%it:0}}function Tc(i){let e="";for(const t of new Uint8Array(i))t<16&&(e+="0"),e+=t.toString(16);return e}let $i=null;async function lt(i){return $i===null&&($i=await Ac()),$i?Ia(i):$c(i)}function $c(i){return new xa().update(i).digest("hex")}async function Ia(i){const e=await crypto.subtle.digest("SHA-1",i);return Tc(e)}async function Ac(){try{if(await Ia(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709")return!0}catch{}return!1}function Oc(i){return{assumeValid:!!(i&32768),extended:!!(i&16384),stage:(i&12288)>>12,nameLength:i&4095}}function Ic(i){const e=i.flags;return e.extended=!1,e.nameLength=Math.min(Buffer.from(i.path).length,4095),(e.assumeValid?32768:0)+(e.extended?16384:0)+((e.stage&3)<<12)+(e.nameLength&4095)}class Rt{constructor(e,t){this._dirty=!1,this._unmergedPaths=t||new Set,this._entries=e||new Map}_addEntry(e){if(e.flags.stage===0)e.stages=[e],this._entries.set(e.path,e),this._unmergedPaths.delete(e.path);else{let t=this._entries.get(e.path);t||(this._entries.set(e.path,e),t=e),t.stages[e.flags.stage]=e,this._unmergedPaths.add(e.path)}}static async from(e){if(Buffer.isBuffer(e))return Rt.fromBuffer(e);if(e===null)return new Rt(null);throw new se("invalid type passed to GitIndex.from")}static async fromBuffer(e){if(e.length===0)throw new se("Index file is empty (.git/index)");const t=new Rt,r=new nt(e),n=r.toString("utf8",4);if(n!=="DIRC")throw new se(`Invalid dircache magic file number: ${n}`);const a=await lt(e.slice(0,-20)),s=e.slice(-20).toString("hex");if(s!==a)throw new se(`Invalid checksum in GitIndex buffer: expected ${s} but saw ${a}`);const o=r.readUInt32BE();if(o!==2)throw new se(`Unsupported dircache version: ${o}`);const c=r.readUInt32BE();let u=0;for(;!r.eof()&&u<c;){const f={};f.ctimeSeconds=r.readUInt32BE(),f.ctimeNanoseconds=r.readUInt32BE(),f.mtimeSeconds=r.readUInt32BE(),f.mtimeNanoseconds=r.readUInt32BE(),f.dev=r.readUInt32BE(),f.ino=r.readUInt32BE(),f.mode=r.readUInt32BE(),f.uid=r.readUInt32BE(),f.gid=r.readUInt32BE(),f.size=r.readUInt32BE(),f.oid=r.slice(20).toString("hex");const d=r.readUInt16BE();f.flags=Oc(d);const h=e.indexOf(0,r.tell()+1)-r.tell();if(h<1)throw new se(`Got a path length of: ${h}`);if(f.path=r.toString("utf8",h),f.path.includes("..\\")||f.path.includes("../"))throw new Gt(f.path);let w=8-(r.tell()-12)%8;for(w===0&&(w=8);w--;){const _=r.readUInt8();if(_!==0)throw new se(`Expected 1-8 null characters but got '${_}' after ${f.path}`);if(r.eof())throw new se("Unexpected end of file")}f.stages=[],t._addEntry(f),u++}return t}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(Aa)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(e=>e.stages.length>1?e.stages.filter(t=>t):e)}*[Symbol.iterator](){for(const e of this.entries)yield e}insert({filepath:e,stats:t,oid:r,stage:n=0}){t||(t={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),t=Nt(t);const a=Buffer.from(e),s={ctimeSeconds:t.ctimeSeconds,ctimeNanoseconds:t.ctimeNanoseconds,mtimeSeconds:t.mtimeSeconds,mtimeNanoseconds:t.mtimeNanoseconds,dev:t.dev,ino:t.ino,mode:t.mode||33188,uid:t.uid,gid:t.gid,size:t.size,path:e,oid:r,flags:{assumeValid:!1,extended:!1,stage:n,nameLength:a.length<4095?a.length:4095},stages:[]};this._addEntry(s),this._dirty=!0}delete({filepath:e}){if(this._entries.has(e))this._entries.delete(e);else for(const t of this._entries.keys())t.startsWith(e+"/")&&this._entries.delete(t);this._unmergedPaths.has(e)&&this._unmergedPaths.delete(e),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:e}){return this._entries.has(e)}render(){return this.entries.map(e=>`${e.mode.toString(8)} ${e.oid}    ${e.path}`).join(`
`)}static async _entryToBuffer(e){const t=Buffer.from(e.path),r=Math.ceil((62+t.length+1)/8)*8,n=Buffer.alloc(r),a=new nt(n),s=Nt(e);return a.writeUInt32BE(s.ctimeSeconds),a.writeUInt32BE(s.ctimeNanoseconds),a.writeUInt32BE(s.mtimeSeconds),a.writeUInt32BE(s.mtimeNanoseconds),a.writeUInt32BE(s.dev),a.writeUInt32BE(s.ino),a.writeUInt32BE(s.mode),a.writeUInt32BE(s.uid),a.writeUInt32BE(s.gid),a.writeUInt32BE(s.size),a.write(e.oid,20,"hex"),a.writeUInt16BE(Ic(e)),a.write(e.path,t.length,"utf8"),n}async toObject(){const e=Buffer.alloc(12),t=new nt(e);t.write("DIRC",4,"utf8"),t.writeUInt32BE(2),t.writeUInt32BE(this.entriesFlat.length);let r=[];for(const o of this.entries)if(r.push(Rt._entryToBuffer(o)),o.stages.length>1)for(const c of o.stages)c&&c!==o&&r.push(Rt._entryToBuffer(c));r=await Promise.all(r);const n=Buffer.concat(r),a=Buffer.concat([e,n]),s=await lt(a);return Buffer.concat([a,Buffer.from(s,"hex")])}}function Or(i,e,t=!0,r=!0){const n=Nt(i),a=Nt(e);return t&&n.mode!==a.mode||n.mtimeSeconds!==a.mtimeSeconds||n.ctimeSeconds!==a.ctimeSeconds||n.uid!==a.uid||n.gid!==a.gid||r&&n.ino!==a.ino||n.size!==a.size}let Ai=null;const Oi=Symbol("IndexCache");function jc(){return{map:new Map,stats:new Map}}async function Bc(i,e,t){const[r,n]=await Promise.all([i.lstat(e),i.read(e)]),a=await Rt.from(n);t.map.set(e,a),t.stats.set(e,r)}async function Cc(i,e,t){const r=t.stats.get(e);if(r===void 0)return!0;if(r===null)return!1;const n=await i.lstat(e);return n===null?!1:Or(r,n)}class Be{static async acquire({fs:e,gitdir:t,cache:r,allowUnmerged:n=!0},a){r[Oi]||(r[Oi]=jc());const s=`${t}/index`;Ai===null&&(Ai=new tr({maxPending:1/0}));let o,c=[];return await Ai.acquire(s,async()=>{const u=r[Oi];await Cc(e,s,u)&&await Bc(e,s,u);const f=u.map.get(s);if(c=f.unmergedPaths,c.length&&!n)throw new nr(c);if(o=await a(f),f._dirty){const d=await f.toObject();await e.write(s,d),u.stats.set(s,await e.lstat(s)),f._dirty=!1}}),o}}function Ir(i){const e=Math.max(i.lastIndexOf("/"),i.lastIndexOf("\\"));return e>-1&&(i=i.slice(e+1)),i}function zt(i){const e=Math.max(i.lastIndexOf("/"),i.lastIndexOf("\\"));return e===-1?".":e===0?"/":i.slice(0,e)}function ja(i){const e=new Map,t=function(n){if(!e.has(n)){const a={type:"tree",fullpath:n,basename:Ir(n),metadata:{},children:[]};e.set(n,a),a.parent=t(zt(n)),a.parent&&a.parent!==a&&a.parent.children.push(a)}return e.get(n)},r=function(n,a){if(!e.has(n)){const s={type:"blob",fullpath:n,basename:Ir(n),metadata:a,parent:t(zt(n)),children:[]};s.parent&&s.parent.children.push(s),e.set(n,s)}return e.get(n)};t(".");for(const n of i)r(n.path,n);return e}function Dc(i){switch(i){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new se(`Unexpected GitTree entry mode: ${i.toString(8)}`)}class Pc{constructor({fs:e,gitdir:t,cache:r}){this.treePromise=Be.acquire({fs:e,gitdir:t,cache:r},async function(a){return ja(a.entries)});const n=this;this.ConstructEntry=class{constructor(s){this._fullpath=s,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return n.type(this)}async mode(){return n.mode(this)}async stat(){return n.stat(this)}async content(){return n.content(this)}async oid(){return n.oid(this)}}}async readdir(e){const t=e._fullpath,n=(await this.treePromise).get(t);if(!n||n.type==="blob")return null;if(n.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${t}'`);const a=n.children.map(s=>s.fullpath);return a.sort(Mr),a}async type(e){return e._type===!1&&await e.stat(),e._type}async mode(e){return e._mode===!1&&await e.stat(),e._mode}async stat(e){if(e._stat===!1){const r=(await this.treePromise).get(e._fullpath);if(!r)throw new Error(`ENOENT: no such file or directory, lstat '${e._fullpath}'`);const n=r.type==="tree"?{}:Nt(r.metadata);e._type=r.type==="tree"?"tree":Dc(n.mode),e._mode=n.mode,r.type==="tree"?e._stat=void 0:e._stat=n}return e._stat}async content(e){}async oid(e){if(e._oid===!1){const r=(await this.treePromise).get(e._fullpath);e._oid=r.metadata.oid}return e._oid}}const Fr=Symbol("GitWalkSymbol");function At(){const i=Object.create(null);return Object.defineProperty(i,Fr,{value:function({fs:e,gitdir:t,cache:r}){return new Pc({fs:e,gitdir:t,cache:r})}}),Object.freeze(i),i}class be extends de{constructor(e){super(`Could not find ${e}.`),this.code=this.name=be.code,this.data={what:e}}}be.code="NotFoundError";class Ue extends de{constructor(e,t,r,n){super(`Object ${e} ${n?`at ${n}`:""}was anticipated to be a ${r} but it is a ${t}.`),this.code=this.name=Ue.code,this.data={oid:e,actual:t,expected:r,filepath:n}}}Ue.code="ObjectTypeError";class _t extends de{constructor(e){super(`Expected a 40-char hex object id but saw "${e}".`),this.code=this.name=_t.code,this.data={value:e}}}_t.code="InvalidOidError";class ar extends de{constructor(e){super(`Could not find a fetch refspec for remote "${e}". Make sure the config file has an entry like the following:
[remote "${e}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=ar.code,this.data={remote:e}}}ar.code="NoRefspecError";class jr{constructor(e){if(this.refs=new Map,this.parsedConfig=[],e){let t=null;this.parsedConfig=e.trim().split(`
`).map(r=>{if(/^\s*#/.test(r))return{line:r,comment:!0};const n=r.indexOf(" ");if(r.startsWith("^")){const a=r.slice(1);return this.refs.set(t+"^{}",a),{line:r,ref:t,peeled:a}}else{const a=r.slice(0,n);return t=r.slice(n+1),this.refs.set(t,a),{line:r,ref:t,oid:a}}})}return this}static from(e){return new jr(e)}delete(e){this.parsedConfig=this.parsedConfig.filter(t=>t.ref!==e),this.refs.delete(e)}toString(){return this.parsedConfig.map(({line:e})=>e).join(`
`)+`
`}}class Br{constructor({remotePath:e,localPath:t,force:r,matchPrefix:n}){Object.assign(this,{remotePath:e,localPath:t,force:r,matchPrefix:n})}static from(e){const[t,r,n,a,s]=e.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),o=t==="+",c=n==="*";if(c!==(s==="*"))throw new se("Invalid refspec");return new Br({remotePath:r,localPath:a,force:o,matchPrefix:c})}translate(e){if(this.matchPrefix){if(e.startsWith(this.remotePath))return this.localPath+e.replace(this.remotePath,"")}else if(e===this.remotePath)return this.localPath;return null}reverseTranslate(e){if(this.matchPrefix){if(e.startsWith(this.localPath))return this.remotePath+e.replace(this.localPath,"")}else if(e===this.localPath)return this.remotePath;return null}}class Xi{constructor(e=[]){this.rules=e}static from(e){const t=[];for(const r of e)t.push(Br.from(r));return new Xi(t)}add(e){const t=Br.from(e);this.rules.push(t)}translate(e){const t=[];for(const r of this.rules)for(const n of e){const a=r.translate(n);a&&t.push([n,a])}return t}translateOne(e){let t=null;for(const r of this.rules){const n=r.translate(e);n&&(t=n)}return t}localNamespaces(){return this.rules.filter(e=>e.matchPrefix).map(e=>e.localPath.replace(/\/$/,""))}}function Nc(i,e){const t=i.replace(/\^\{\}$/,""),r=e.replace(/\^\{\}$/,""),n=-(t<r)||+(t>r);return n===0?i.endsWith("^{}")?1:-1:n}const zc=i=>{if(typeof i=="number")return i;i=i.toLowerCase();let e=parseInt(i);return i.endsWith("k")&&(e*=1024),i.endsWith("m")&&(e*=1024*1024),i.endsWith("g")&&(e*=1024*1024*1024),e},er=i=>{if(typeof i=="boolean")return i;if(i=i.trim().toLowerCase(),i==="true"||i==="yes"||i==="on")return!0;if(i==="false"||i==="no"||i==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${i}`)},Jn={core:{filemode:er,bare:er,logallrefupdates:er,symlinks:er,ignorecase:er,bigFileThreshold:zc}},Mc=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,Fc=/^[A-Za-z0-9-.]+$/,Uc=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Lc=/^[A-Za-z][A-Za-z-]*$/,Hc=/^(.*?)( *[#;].*)$/,qc=i=>{const e=Mc.exec(i);if(e!=null){const[t,r]=e.slice(1);return[t,r]}return null},Zc=i=>{const e=Uc.exec(i);if(e!=null){const[t,r="true"]=e.slice(1),n=Gc(r),a=Wc(n);return[t,a]}return null},Gc=i=>{const e=Hc.exec(i);if(e==null)return i;const[t,r]=e.slice(1);return Qn(t)&&Qn(r)?`${t}${r}`:t},Qn=i=>(i.match(/(?:^|[^\\])"/g)||[]).length%2!==0,Wc=i=>i.split("").reduce((e,t,r,n)=>{const a=t==='"'&&n[r-1]!=="\\",s=t==="\\"&&n[r+1]==='"';return a||s?e:e+t},""),ea=i=>i!=null?i.toLowerCase():null,Mi=(i,e,t)=>[ea(i),e,ea(t)].filter(r=>r!=null).join("."),ta=i=>{const e=i.split("."),t=e.shift(),r=e.pop(),n=e.length?e.join("."):void 0;return{section:t,subsection:n,name:r,path:Mi(t,n,r),sectionPath:Mi(t,n,null),isSection:!!t}},Xc=(i,e)=>i.reduce((t,r,n)=>e(r)?n:t,-1);class Ki{constructor(e){let t=null,r=null;this.parsedConfig=e?e.split(`
`).map(n=>{let a=null,s=null;const o=n.trim(),c=qc(o),u=c!=null;if(u)[t,r]=c;else{const d=Zc(o);d!=null&&([a,s]=d)}const f=Mi(t,r,a);return{line:n,isSection:u,section:t,subsection:r,name:a,value:s,path:f}}):[]}static from(e){return new Ki(e)}async get(e,t=!1){const r=ta(e).path,n=this.parsedConfig.filter(a=>a.path===r).map(({section:a,name:s,value:o})=>{const c=Jn[a]&&Jn[a][s];return c?c(o):o});return t?n:n.pop()}async getall(e){return this.get(e,!0)}async getSubsections(e){return this.parsedConfig.filter(t=>t.isSection&&t.section===e).map(t=>t.subsection)}async deleteSection(e,t){this.parsedConfig=this.parsedConfig.filter(r=>!(r.section===e&&r.subsection===t))}async append(e,t){return this.set(e,t,!0)}async set(e,t,r=!1){const{section:n,subsection:a,name:s,path:o,sectionPath:c,isSection:u}=ta(e),f=Xc(this.parsedConfig,d=>d.path===o);if(t==null)f!==-1&&this.parsedConfig.splice(f,1);else if(f!==-1){const d=this.parsedConfig[f],h=Object.assign({},d,{name:s,value:t,modified:!0});r?this.parsedConfig.splice(f+1,0,h):this.parsedConfig[f]=h}else{const d=this.parsedConfig.findIndex(w=>w.path===c),h={section:n,subsection:a,name:s,value:t,modified:!0,path:o};if(Fc.test(n)&&Lc.test(s))if(d>=0)this.parsedConfig.splice(d+1,0,h);else{const w={isSection:u,section:n,subsection:a,modified:!0,path:c};this.parsedConfig.push(w,h)}}}toString(){return this.parsedConfig.map(({line:e,section:t,subsection:r,name:n,value:a,modified:s=!1})=>s?n!=null&&a!=null?typeof a=="string"&&/[#;]/.test(a)?`	${n} = "${a}"`:`	${n} = ${a}`:r!=null?`[${t} "${r}"]`:`[${t}]`:e).join(`
`)}}class Oe{static async get({fs:e,gitdir:t}){const r=await e.read(`${t}/config`,{encoding:"utf8"});return Ki.from(r)}static async save({fs:e,gitdir:t,config:r}){await e.write(`${t}/config`,r.toString(),{encoding:"utf8"})}}const Rr=i=>[`${i}`,`refs/${i}`,`refs/tags/${i}`,`refs/heads/${i}`,`refs/remotes/${i}`,`refs/remotes/${i}/HEAD`],Kc=["config","description","index","shallow","commondir"];let Ii;async function mt(i,e){return Ii===void 0&&(Ii=new tr),Ii.acquire(i,e)}class G{static async updateRemoteRefs({fs:e,gitdir:t,remote:r,refs:n,symrefs:a,tags:s,refspecs:o=void 0,prune:c=!1,pruneTags:u=!1}){for(const b of n.values())if(!b.match(/[0-9a-f]{40}/))throw new _t(b);const f=await Oe.get({fs:e,gitdir:t});if(!o){if(o=await f.getall(`remote.${r}.fetch`),o.length===0)throw new ar(r);o.unshift(`+HEAD:refs/remotes/${r}/HEAD`)}const d=Xi.from(o),h=new Map;if(u){const b=await G.listRefs({fs:e,gitdir:t,filepath:"refs/tags"});await G.deleteRefs({fs:e,gitdir:t,refs:b.map(v=>`refs/tags/${v}`)})}if(s){for(const b of n.keys())if(b.startsWith("refs/tags")&&!b.endsWith("^{}")&&!await G.exists({fs:e,gitdir:t,ref:b})){const v=n.get(b);h.set(b,v)}}const w=d.translate([...n.keys()]);for(const[b,v]of w){const k=n.get(b);h.set(v,k)}const _=d.translate([...a.keys()]);for(const[b,v]of _){const k=a.get(b),S=d.translateOne(k);S&&h.set(v,`ref: ${S}`)}const y=[];if(c){for(const b of d.localNamespaces()){const v=(await G.listRefs({fs:e,gitdir:t,filepath:b})).map(k=>`${b}/${k}`);for(const k of v)h.has(k)||y.push(k)}y.length>0&&await G.deleteRefs({fs:e,gitdir:t,refs:y})}for(const[b,v]of h)await mt(b,async()=>e.write(M.join(t,b),`${v.trim()}
`,"utf8"));return{pruned:y}}static async writeRef({fs:e,gitdir:t,ref:r,value:n}){if(!n.match(/[0-9a-f]{40}/))throw new _t(n);await mt(r,async()=>e.write(M.join(t,r),`${n.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:e,gitdir:t,ref:r,value:n}){await mt(r,async()=>e.write(M.join(t,r),`ref: ${n.trim()}
`,"utf8"))}static async deleteRef({fs:e,gitdir:t,ref:r}){return G.deleteRefs({fs:e,gitdir:t,refs:[r]})}static async deleteRefs({fs:e,gitdir:t,refs:r}){await Promise.all(r.map(o=>e.rm(M.join(t,o))));let n=await mt("packed-refs",async()=>e.read(`${t}/packed-refs`,{encoding:"utf8"}));const a=jr.from(n),s=a.refs.size;for(const o of r)a.refs.has(o)&&a.delete(o);a.refs.size<s&&(n=a.toString(),await mt("packed-refs",async()=>e.write(`${t}/packed-refs`,n,{encoding:"utf8"})))}static async resolve({fs:e,gitdir:t,ref:r,depth:n=void 0}){if(n!==void 0&&(n--,n===-1))return r;if(r.startsWith("ref: "))return r=r.slice(5),G.resolve({fs:e,gitdir:t,ref:r,depth:n});if(r.length===40&&/[0-9a-f]{40}/.test(r))return r;const a=await G.packedRefs({fs:e,gitdir:t}),s=Rr(r).filter(o=>!Kc.includes(o));for(const o of s){const c=await mt(o,async()=>await e.read(`${t}/${o}`,{encoding:"utf8"})||a.get(o));if(c)return G.resolve({fs:e,gitdir:t,ref:c.trim(),depth:n})}throw new be(r)}static async exists({fs:e,gitdir:t,ref:r}){try{return await G.expand({fs:e,gitdir:t,ref:r}),!0}catch{return!1}}static async expand({fs:e,gitdir:t,ref:r}){if(r.length===40&&/[0-9a-f]{40}/.test(r))return r;const n=await G.packedRefs({fs:e,gitdir:t}),a=Rr(r);for(const s of a)if(await mt(s,async()=>e.exists(`${t}/${s}`))||n.has(s))return s;throw new be(r)}static async expandAgainstMap({ref:e,map:t}){const r=Rr(e);for(const n of r)if(await t.has(n))return n;throw new be(e)}static resolveAgainstMap({ref:e,fullref:t=e,depth:r=void 0,map:n}){if(r!==void 0&&(r--,r===-1))return{fullref:t,oid:e};if(e.startsWith("ref: "))return e=e.slice(5),G.resolveAgainstMap({ref:e,fullref:t,depth:r,map:n});if(e.length===40&&/[0-9a-f]{40}/.test(e))return{fullref:t,oid:e};const a=Rr(e);for(const s of a){const o=n.get(s);if(o)return G.resolveAgainstMap({ref:o.trim(),fullref:s,depth:r,map:n})}throw new be(e)}static async packedRefs({fs:e,gitdir:t}){const r=await mt("packed-refs",async()=>e.read(`${t}/packed-refs`,{encoding:"utf8"}));return jr.from(r).refs}static async listRefs({fs:e,gitdir:t,filepath:r}){const n=G.packedRefs({fs:e,gitdir:t});let a=null;try{a=await e.readdirDeep(`${t}/${r}`),a=a.map(s=>s.replace(`${t}/${r}/`,""))}catch{a=[]}for(let s of(await n).keys())s.startsWith(r)&&(s=s.replace(r+"/",""),a.includes(s)||a.push(s));return a.sort(Nc),a}static async listBranches({fs:e,gitdir:t,remote:r}){return r?G.listRefs({fs:e,gitdir:t,filepath:`refs/remotes/${r}`}):G.listRefs({fs:e,gitdir:t,filepath:"refs/heads"})}static async listTags({fs:e,gitdir:t}){return(await G.listRefs({fs:e,gitdir:t,filepath:"refs/tags"})).filter(n=>!n.endsWith("^{}"))}}function Yc(i,e){return Mr(ra(i),ra(e))}function ra(i){return i.mode==="040000"?i.path+"/":i.path}function Ba(i){switch(i){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new se(`Unexpected GitTree entry mode: ${i}`)}function Vc(i){const e=[];let t=0;for(;t<i.length;){const r=i.indexOf(32,t);if(r===-1)throw new se(`GitTree: Error parsing buffer at byte location ${t}: Could not find the next space character.`);const n=i.indexOf(0,t);if(n===-1)throw new se(`GitTree: Error parsing buffer at byte location ${t}: Could not find the next null character.`);let a=i.slice(t,r).toString("utf8");a==="40000"&&(a="040000");const s=Ba(a),o=i.slice(r+1,n).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new Gt(o);const c=i.slice(n+1,n+21).toString("hex");t=n+21,e.push({mode:a,path:o,oid:c,type:s})}return e}function Jc(i){if(typeof i=="number"&&(i=i.toString(8)),i.match(/^0?4.*/))return"040000";if(i.match(/^1006.*/))return"100644";if(i.match(/^1007.*/))return"100755";if(i.match(/^120.*/))return"120000";if(i.match(/^160.*/))return"160000";throw new se(`Could not understand file mode: ${i}`)}function Qc(i){return!i.oid&&i.sha&&(i.oid=i.sha),i.mode=Jc(i.mode),i.type||(i.type=Ba(i.mode)),i}class qe{constructor(e){if(Buffer.isBuffer(e))this._entries=Vc(e);else if(Array.isArray(e))this._entries=e.map(Qc);else throw new se("invalid type passed to GitTree constructor");this._entries.sort(Aa)}static from(e){return new qe(e)}render(){return this._entries.map(e=>`${e.mode} ${e.type} ${e.oid}    ${e.path}`).join(`
`)}toObject(){const e=[...this._entries];return e.sort(Yc),Buffer.concat(e.map(t=>{const r=Buffer.from(t.mode.replace(/^0/,"")),n=Buffer.from(" "),a=Buffer.from(t.path,"utf8"),s=Buffer.from([0]),o=Buffer.from(t.oid,"hex");return Buffer.concat([r,n,a,s,o])}))}entries(){return this._entries}*[Symbol.iterator](){for(const e of this._entries)yield e}}class Wt{static wrap({type:e,object:t}){return Buffer.concat([Buffer.from(`${e} ${t.byteLength.toString()}\0`),Buffer.from(t)])}static unwrap(e){const t=e.indexOf(32),r=e.indexOf(0),n=e.slice(0,t).toString("utf8"),a=e.slice(t+1,r).toString("utf8"),s=e.length-(r+1);if(parseInt(a)!==s)throw new se(`Length mismatch: expected ${a} bytes but got ${s} instead.`);return{type:n,object:Buffer.from(e.slice(r+1))}}}async function Ca({fs:i,gitdir:e,oid:t}){const r=`objects/${t.slice(0,2)}/${t.slice(2)}`,n=await i.read(`${e}/${r}`);return n?{object:n,format:"deflated",source:r}:null}function ef(i,e){const t=new nt(i),r=ia(t);if(r!==e.byteLength)throw new se(`applyDelta expected source buffer to be ${r} bytes but the provided buffer was ${e.length} bytes`);const n=ia(t);let a;const s=aa(t,e);if(s.byteLength===n)a=s;else{a=Buffer.alloc(n);const o=new nt(a);for(o.copy(s);!t.eof();)o.copy(aa(t,e));const c=o.tell();if(n!==c)throw new se(`applyDelta expected target buffer to be ${n} bytes but the resulting buffer was ${c} bytes`)}return a}function ia(i){let e=0,t=0,r=null;do r=i.readUInt8(),e|=(r&127)<<t,t+=7;while(r&128);return e}function na(i,e,t){let r=0,n=0;for(;t--;)e&1&&(r|=i.readUInt8()<<n),e>>=1,n+=8;return r}function aa(i,e){const t=i.readUInt8(),r=128,n=15,a=112;if(t&r){const s=na(i,t&n,4);let o=na(i,(t&a)>>4,3);return o===0&&(o=65536),e.slice(s,s+o)}else return i.slice(t)}function tf(i){let e=[i];return{next(){return Promise.resolve({done:e.length===0,value:e.pop()})},return(){return e=[],{}},[Symbol.asyncIterator](){return this}}}function Da(i){return i[Symbol.asyncIterator]?i[Symbol.asyncIterator]():i[Symbol.iterator]?i[Symbol.iterator]():i.next?i:tf(i)}class Pa{constructor(e){if(typeof Buffer>"u")throw new Error("Missing Buffer dependency");this.stream=Da(e),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(e){if(!this.eof())return this.started||await this._init(),this.cursor+e>this.buffer.length&&(this._trim(),await this._accumulate(e)),this._moveCursor(e),this.buffer.slice(this.undoCursor,this.cursor)}async skip(e){this.eof()||(this.started||await this._init(),this.cursor+e>this.buffer.length&&(this._trim(),await this._accumulate(e)),this._moveCursor(e))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:e,value:t}=await this.stream.next();return e&&(this._ended=!0,!t)?Buffer.alloc(0):(t&&(t=Buffer.from(t)),t)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(e){this.undoCursor=this.cursor,this.cursor+=e,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(e){if(this._ended)return;const t=[this.buffer];for(;this.cursor+e>rf(t);){const r=await this._next();if(this._ended)break;t.push(r)}this.buffer=Buffer.concat(t)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function rf(i){return i.reduce((e,t)=>e+t.length,0)}async function nf(i,e){const t=new Pa(i);let r=await t.read(4);if(r=r.toString("utf8"),r!=="PACK")throw new se(`Invalid PACK header '${r}'`);let n=await t.read(4);if(n=n.readUInt32BE(0),n!==2)throw new se(`Invalid packfile version: ${n}`);let a=await t.read(4);if(a=a.readUInt32BE(0),!(a<1))for(;!t.eof()&&a--;){const s=t.tell(),{type:o,length:c,ofs:u,reference:f}=await af(t),d=new Wi.Inflate;for(;!d.result;){const h=await t.chunk();if(!h)break;if(d.push(h,!1),d.err)throw new se(`Pako error: ${d.msg}`);if(d.result){if(d.result.length!==c)throw new se("Inflated object size is different from that stated in packfile.");await t.undo(),await t.read(h.length-d.strm.avail_in);const w=t.tell();await e({data:d.result,type:o,num:a,offset:s,end:w,reference:f,ofs:u})}}}}async function af(i){let e=await i.byte();const t=e>>4&7;let r=e&15;if(e&128){let s=4;do e=await i.byte(),r|=(e&127)<<s,s+=7;while(e&128)}let n,a;if(t===6){let s=0;n=0;const o=[];do e=await i.byte(),n|=(e&127)<<s,s+=7,o.push(e);while(e&128);a=Buffer.from(o)}return t===7&&(a=await i.read(20)),{type:t,length:r,ofs:n,reference:a}}async function Na(i){return Wi.inflate(i)}function sf(i){const e=[];let t=0,r=0;do{t=i.readUInt8();const n=t&127;e.push(n),r=t&128}while(r);return e.reduce((n,a)=>n+1<<7|a,-1)}function of(i,e){let t=e,r=4,n=null;do n=i.readUInt8(),t|=(n&127)<<r,r+=7;while(n&128);return t}class Mt{constructor(e){Object.assign(this,e),this.offsetCache={}}static async fromIdx({idx:e,getExternalRefDelta:t}){const r=new nt(e);if(r.slice(4).toString("hex")!=="ff744f63")return;const a=r.readUInt32BE();if(a!==2)throw new se(`Unable to read version ${a} packfile IDX. (Only version 2 supported)`);if(e.byteLength>2048*1024*1024)throw new se("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");r.seek(r.tell()+4*255);const s=r.readUInt32BE(),o=[];for(let f=0;f<s;f++){const d=r.slice(20).toString("hex");o[f]=d}r.seek(r.tell()+4*s);const c=new Map;for(let f=0;f<s;f++)c.set(o[f],r.readUInt32BE());const u=r.slice(20).toString("hex");return new Mt({hashes:o,crcs:{},offsets:c,packfileSha:u,getExternalRefDelta:t})}static async fromPack({pack:e,getExternalRefDelta:t,onProgress:r}){const n={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},a={},s=e.slice(-20).toString("hex"),o=[],c={},u=new Map;let f=null,d=null;await nf([e],async({data:b,type:v,reference:k,offset:S,num:O})=>{f===null&&(f=O);const I=Math.floor((f-O)*100/f);I!==d&&r&&await r({phase:"Receiving objects",loaded:f-O,total:f}),d=I,v=n[v],["commit","tree","blob","tag"].includes(v)?a[S]={type:v,offset:S}:v==="ofs-delta"?a[S]={type:v,offset:S}:v==="ref-delta"&&(a[S]={type:v,offset:S})});const h=Object.keys(a).map(Number);for(const[b,v]of h.entries()){const k=b+1===h.length?e.byteLength-20:h[b+1],S=a[v],O=ac.buf(e.slice(v,k))>>>0;S.end=k,S.crc=O}const w=new Mt({pack:Promise.resolve(e),packfileSha:s,crcs:c,hashes:o,offsets:u,getExternalRefDelta:t});d=null;let _=0;const y=[0,0,0,0,0,0,0,0,0,0,0,0];for(let b in a){b=Number(b);const v=Math.floor(_*100/f);v!==d&&r&&await r({phase:"Resolving deltas",loaded:_,total:f}),_++,d=v;const k=a[b];if(!k.oid)try{w.readDepth=0,w.externalReadDepth=0;const{type:S,object:O}=await w.readSlice({start:b});y[w.readDepth]+=1;const I=await lt(Wt.wrap({type:S,object:O}));k.oid=I,o.push(I),u.set(I,b),c[I]=k.crc}catch{continue}}return o.sort(),w}async toBuffer(){const e=[],t=(u,f)=>{e.push(Buffer.from(u,f))};t("ff744f63","hex"),t("00000002","hex");const r=new nt(Buffer.alloc(256*4));for(let u=0;u<256;u++){let f=0;for(const d of this.hashes)parseInt(d.slice(0,2),16)<=u&&f++;r.writeUInt32BE(f)}e.push(r.buffer);for(const u of this.hashes)t(u,"hex");const n=new nt(Buffer.alloc(this.hashes.length*4));for(const u of this.hashes)n.writeUInt32BE(this.crcs[u]);e.push(n.buffer);const a=new nt(Buffer.alloc(this.hashes.length*4));for(const u of this.hashes)a.writeUInt32BE(this.offsets.get(u));e.push(a.buffer),t(this.packfileSha,"hex");const s=Buffer.concat(e),o=await lt(s),c=Buffer.alloc(20);return c.write(o,"hex"),Buffer.concat([s,c])}async load({pack:e}){this.pack=e}async unload(){this.pack=null}async read({oid:e}){if(!this.offsets.get(e)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(e);throw new se(`Could not read object ${e} from packfile`)}const t=this.offsets.get(e);return this.readSlice({start:t})}async readSlice({start:e}){if(this.offsetCache[e])return Object.assign({},this.offsetCache[e]);this.readDepth++;const t={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new se("Tried to read from a GitPackIndex with no packfile loaded into memory");const r=(await this.pack).slice(e),n=new nt(r),a=n.readUInt8(),s=a&112;let o=t[s];if(o===void 0)throw new se("Unrecognized type: 0b"+s.toString(2));const c=a&15;let u=c;a&128&&(u=of(n,c));let d=null,h=null;if(o==="ofs_delta"){const _=sf(n),y=e-_;({object:d,type:o}=await this.readSlice({start:y}))}if(o==="ref_delta"){const _=n.slice(20).toString("hex");({object:d,type:o}=await this.read({oid:_}))}const w=r.slice(n.tell());if(h=Buffer.from(await Na(w)),h.byteLength!==u)throw new se(`Packfile told us object would have length ${u} but it had length ${h.byteLength}`);return d&&(h=Buffer.from(ef(h,d))),this.readDepth>3&&(this.offsetCache[e]={type:o,object:h}),{type:o,format:"content",object:h}}}const Tr=Symbol("PackfileCache");async function cf({fs:i,filename:e,getExternalRefDelta:t,emitter:r,emitterPrefix:n}){const a=await i.read(e);return Mt.fromIdx({idx:a,getExternalRefDelta:t})}function Yi({fs:i,cache:e,filename:t,getExternalRefDelta:r,emitter:n,emitterPrefix:a}){e[Tr]||(e[Tr]=new Map);let s=e[Tr].get(t);return s||(s=cf({fs:i,filename:t,getExternalRefDelta:r,emitter:n,emitterPrefix:a}),e[Tr].set(t,s)),s}async function ff({fs:i,cache:e,gitdir:t,oid:r,format:n="content",getExternalRefDelta:a}){let s=await i.readdir(M.join(t,"objects/pack"));s=s.filter(o=>o.endsWith(".idx"));for(const o of s){const c=`${t}/objects/pack/${o}`,u=await Yi({fs:i,cache:e,filename:c,getExternalRefDelta:a});if(u.error)throw new se(u.error);if(u.offsets.has(r)){if(!u.pack){const d=c.replace(/idx$/,"pack");u.pack=i.read(d)}const f=await u.read({oid:r,getExternalRefDelta:a});return f.format="content",f.source=`objects/pack/${o.replace(/idx$/,"pack")}`,f}}return null}async function xe({fs:i,cache:e,gitdir:t,oid:r,format:n="content"}){const a=f=>xe({fs:i,cache:e,gitdir:t,oid:f});let s;if(r==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(s={format:"wrapped",object:Buffer.from("tree 0\0")}),s||(s=await Ca({fs:i,gitdir:t,oid:r})),!s){if(s=await ff({fs:i,cache:e,gitdir:t,oid:r,getExternalRefDelta:a}),!s)throw new be(r);return s}if(n==="deflated"||(s.format==="deflated"&&(s.object=Buffer.from(await Na(s.object)),s.format="wrapped"),n==="wrapped"))return s;const o=await lt(s.object);if(o!==r)throw new se(`SHA check failed! Expected ${r}, computed ${o}`);const{object:c,type:u}=Wt.unwrap(s.object);if(s.type=u,s.object=c,s.format="content",n==="content")return s;throw new se(`invalid requested format "${n}"`)}class et extends de{constructor(e,t,r=!0){super(`Failed to create ${e} at ${t} because it already exists.${r?` (Hint: use 'force: true' parameter to overwrite existing ${e}.)`:""}`),this.code=this.name=et.code,this.data={noun:e,where:t,canForce:r}}}et.code="AlreadyExistsError";class sr extends de{constructor(e,t,r){super(`Found multiple ${e} matching "${t}" (${r.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=sr.code,this.data={nouns:e,short:t,matches:r}}}sr.code="AmbiguousError";class or extends de{constructor(e){super(`Your local changes to the following files would be overwritten by checkout: ${e.join(", ")}`),this.code=this.name=or.code,this.data={filepaths:e}}}or.code="CheckoutConflictError";class cr extends de{constructor(e,t){super(`Failed to checkout "${e}" because commit ${t} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=cr.code,this.data={ref:e,oid:t}}}cr.code="CommitNotFetchedError";class fr extends de{constructor(){super("Empty response from git server."),this.code=this.name=fr.code,this.data={}}}fr.code="EmptyServerResponseError";class lr extends de{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=lr.code,this.data={}}}lr.code="FastForwardError";class ur extends de{constructor(e,t){super(`One or more branches were not updated: ${e}`),this.code=this.name=ur.code,this.data={prettyDetails:e,result:t}}}ur.code="GitPushError";class Ft extends de{constructor(e,t,r){super(`HTTP Error: ${e} ${t}`),this.code=this.name=Ft.code,this.data={statusCode:e,statusMessage:t,response:r}}}Ft.code="HttpError";class gt extends de{constructor(e){let t="invalid filepath";e==="leading-slash"||e==="trailing-slash"?t='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':e==="directory"&&(t='"filepath" should not be a directory.'),super(t),this.code=this.name=gt.code,this.data={reason:e}}}gt.code="InvalidFilepathError";class Qe extends de{constructor(e,t){super(`"${e}" would be an invalid git reference. (Hint: a valid alternative would be "${t}".)`),this.code=this.name=Qe.code,this.data={ref:e,suggestion:t}}}Qe.code="InvalidRefNameError";class hr extends de{constructor(e){super(`Maximum search depth of ${e} exceeded.`),this.code=this.name=hr.code,this.data={depth:e}}}hr.code="MaxDepthError";class Xt extends de{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Xt.code,this.data={}}}Xt.code="MergeNotSupportedError";class Kt extends de{constructor(e,t,r,n){super(`Automatic merge failed with one or more merge conflicts in the following files: ${e.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Kt.code,this.data={filepaths:e,bothModified:t,deleteByUs:r,deleteByTheirs:n}}}Kt.code="MergeConflictError";class ze extends de{constructor(e){super(`No name was provided for ${e} in the argument or in the .git/config file.`),this.code=this.name=ze.code,this.data={role:e}}}ze.code="MissingNameError";class He extends de{constructor(e){super(`The function requires a "${e}" parameter but none was provided.`),this.code=this.name=He.code,this.data={parameter:e}}}He.code="MissingParameterError";class dr extends de{constructor(e){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=dr.code,this.data={errors:e},this.errors=e}}dr.code="MultipleGitError";class Ot extends de{constructor(e,t){super(`Expected "${e}" but received "${t}".`),this.code=this.name=Ot.code,this.data={expected:e,actual:t}}}Ot.code="ParseError";class Ut extends de{constructor(e){let t="";e==="not-fast-forward"?t=" because it was not a simple fast-forward":e==="tag-exists"&&(t=" because tag already exists"),super(`Push rejected${t}. Use "force: true" to override.`),this.code=this.name=Ut.code,this.data={reason:e}}}Ut.code="PushRejectedError";class pt extends de{constructor(e,t){super(`Remote does not support the "${e}" so the "${t}" parameter cannot be used.`),this.code=this.name=pt.code,this.data={capability:e,parameter:t}}}pt.code="RemoteCapabilityError";class wr extends de{constructor(e,t){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${e}`),this.code=this.name=wr.code,this.data={preview:e,response:t}}}wr.code="SmartHttpError";class mr extends de{constructor(e,t,r){super(`Git remote "${e}" uses an unrecognized transport protocol: "${t}"`),this.code=this.name=mr.code,this.data={url:e,transport:t,suggestion:r}}}mr.code="UnknownTransportError";class pr extends de{constructor(e){super(`Cannot parse remote URL: "${e}"`),this.code=this.name=pr.code,this.data={url:e}}}pr.code="UrlParseError";class Yt extends de{constructor(){super("The operation was canceled."),this.code=this.name=Yt.code,this.data={}}}Yt.code="UserCanceledError";class _r extends de{constructor(e){super(`Could not merge index: Entry for '${e}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=_r.code,this.data={filepath:e}}}_r.code="IndexResetError";class gr extends de{constructor(e){super(`"${e}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=gr.code,this.data={ref:e}}}gr.code="NoCommitError";var za=Object.freeze({__proto__:null,AlreadyExistsError:et,AmbiguousError:sr,CheckoutConflictError:or,CommitNotFetchedError:cr,EmptyServerResponseError:fr,FastForwardError:lr,GitPushError:ur,HttpError:Ft,InternalError:se,InvalidFilepathError:gt,InvalidOidError:_t,InvalidRefNameError:Qe,MaxDepthError:hr,MergeNotSupportedError:Xt,MergeConflictError:Kt,MissingNameError:ze,MissingParameterError:He,MultipleGitError:dr,NoRefspecError:ar,NotFoundError:be,ObjectTypeError:Ue,ParseError:Ot,PushRejectedError:Ut,RemoteCapabilityError:pt,SmartHttpError:wr,UnknownTransportError:mr,UnsafeFilepathError:Gt,UrlParseError:pr,UserCanceledError:Yt,UnmergedPathsError:nr,IndexResetError:_r,NoCommitError:gr});function Fi({name:i,email:e,timestamp:t,timezoneOffset:r}){return r=lf(r),`${i} <${e}> ${t} ${r}`}function lf(i){const e=uf(hf(i));i=Math.abs(i);const t=Math.floor(i/60);i-=t*60;let r=String(t),n=String(i);return r.length<2&&(r="0"+r),n.length<2&&(n="0"+n),(e===-1?"-":"+")+r+n}function uf(i){return Math.sign(i)||(Object.is(i,-0)?-1:1)}function hf(i){return i===0?i:-i}function ct(i){return i=i.replace(/\r/g,""),i=i.replace(/^\n+/,""),i=i.replace(/\n+$/,"")+`
`,i}function Cr(i){const[,e,t,r,n]=i.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:e,email:t,timestamp:Number(r),timezoneOffset:df(n)}}function df(i){let[,e,t,r]=i.match(/(\+|-)(\d\d)(\d\d)/);return r=(e==="+"?1:-1)*(Number(t)*60+Number(r)),wf(r)}function wf(i){return i===0?i:-i}class Fe{constructor(e){if(typeof e=="string")this._tag=e;else if(Buffer.isBuffer(e))this._tag=e.toString("utf8");else if(typeof e=="object")this._tag=Fe.render(e);else throw new se("invalid type passed to GitAnnotatedTag constructor")}static from(e){return new Fe(e)}static render(e){return`object ${e.object}
type ${e.type}
tag ${e.tag}
tagger ${Fi(e.tagger)}

${e.message}
${e.gpgsig?e.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const e=this.withoutSignature();return e.slice(e.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const e=this.justHeaders().split(`
`),t=[];for(const n of e)n[0]===" "?t[t.length-1]+=`
`+n.slice(1):t.push(n);const r={};for(const n of t){const a=n.slice(0,n.indexOf(" ")),s=n.slice(n.indexOf(" ")+1);Array.isArray(r[a])?r[a].push(s):r[a]=s}return r.tagger&&(r.tagger=Cr(r.tagger)),r.committer&&(r.committer=Cr(r.committer)),r}withoutSignature(){const e=ct(this._tag);return e.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?e:e.slice(0,e.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const e=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return ct(e)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(e,t,r){const n=e.payload();let{signature:a}=await t({payload:n,secretKey:r});a=ct(a);const s=n+a;return Fe.from(s)}}function ji(i){return i.trim().split(`
`).map(e=>" "+e).join(`
`)+`
`}function mf(i){return i.split(`
`).map(e=>e.replace(/^ /,"")).join(`
`)}class ke{constructor(e){if(typeof e=="string")this._commit=e;else if(Buffer.isBuffer(e))this._commit=e.toString("utf8");else if(typeof e=="object")this._commit=ke.render(e);else throw new se("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:e,signature:t}){const r=ke.justHeaders(e),n=ke.justMessage(e),a=ct(r+`
gpgsig`+ji(t)+`
`+n);return new ke(a)}static from(e){return new ke(e)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return ke.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(e){return ct(e.slice(e.indexOf(`

`)+2))}static justHeaders(e){return e.slice(0,e.indexOf(`

`))}parseHeaders(){const e=ke.justHeaders(this._commit).split(`
`),t=[];for(const n of e)n[0]===" "?t[t.length-1]+=`
`+n.slice(1):t.push(n);const r={parent:[]};for(const n of t){const a=n.slice(0,n.indexOf(" ")),s=n.slice(n.indexOf(" ")+1);Array.isArray(r[a])?r[a].push(s):r[a]=s}return r.author&&(r.author=Cr(r.author)),r.committer&&(r.committer=Cr(r.committer)),r}static renderHeaders(e){let t="";if(e.tree?t+=`tree ${e.tree}
`:t+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,e.parent){if(e.parent.length===void 0)throw new se("commit 'parent' property should be an array");for(const a of e.parent)t+=`parent ${a}
`}const r=e.author;t+=`author ${Fi(r)}
`;const n=e.committer||e.author;return t+=`committer ${Fi(n)}
`,e.gpgsig&&(t+="gpgsig"+ji(e.gpgsig)),t}static render(e){return ke.renderHeaders(e)+`
`+ct(e.message)}render(){return this._commit}withoutSignature(){const e=ct(this._commit);if(e.indexOf(`
gpgsig`)===-1)return e;const t=e.slice(0,e.indexOf(`
gpgsig`)),r=e.slice(e.indexOf(`-----END PGP SIGNATURE-----
`)+28);return ct(t+`
`+r)}isolateSignature(){const e=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return mf(e)}static async sign(e,t,r){const n=e.withoutSignature(),a=ke.justMessage(e._commit);let{signature:s}=await t({payload:n,secretKey:r});s=ct(s);const c=ke.justHeaders(e._commit)+`
gpgsig`+ji(s)+`
`+a;return ke.from(c)}}async function Lt({fs:i,cache:e,gitdir:t,oid:r}){if(r==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:qe.from([]),oid:r};const{type:n,object:a}=await xe({fs:i,cache:e,gitdir:t,oid:r});if(n==="tag")return r=Fe.from(a).parse().object,Lt({fs:i,cache:e,gitdir:t,oid:r});if(n==="commit")return r=ke.from(a).parse().tree,Lt({fs:i,cache:e,gitdir:t,oid:r});if(n!=="tree")throw new Ue(r,n,"tree");return{tree:qe.from(a),oid:r}}class pf{constructor({fs:e,gitdir:t,ref:r,cache:n}){this.fs=e,this.cache=n,this.gitdir=t,this.mapPromise=(async()=>{const s=new Map;let o;try{o=await G.resolve({fs:e,gitdir:t,ref:r})}catch(u){u instanceof be&&(o="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const c=await Lt({fs:e,cache:this.cache,gitdir:t,oid:o});return c.type="tree",c.mode="40000",s.set(".",c),s})();const a=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(e){const t=e._fullpath,{fs:r,cache:n,gitdir:a}=this,s=await this.mapPromise,o=s.get(t);if(!o)throw new Error(`No obj for ${t}`);const c=o.oid;if(!c)throw new Error(`No oid for obj ${JSON.stringify(o)}`);if(o.type!=="tree")return null;const{type:u,object:f}=await xe({fs:r,cache:n,gitdir:a,oid:c});if(u!==o.type)throw new Ue(c,u,o.type);const d=qe.from(f);for(const h of d)s.set(M.join(t,h.path),h);return d.entries().map(h=>M.join(t,h.path))}async type(e){if(e._type===!1){const t=await this.mapPromise,{type:r}=t.get(e._fullpath);e._type=r}return e._type}async mode(e){if(e._mode===!1){const t=await this.mapPromise,{mode:r}=t.get(e._fullpath);e._mode=Oa(parseInt(r,8))}return e._mode}async stat(e){}async content(e){if(e._content===!1){const t=await this.mapPromise,{fs:r,cache:n,gitdir:a}=this,o=t.get(e._fullpath).oid,{type:c,object:u}=await xe({fs:r,cache:n,gitdir:a,oid:o});c!=="blob"?e._content=void 0:e._content=new Uint8Array(u)}return e._content}async oid(e){if(e._oid===!1){const r=(await this.mapPromise).get(e._fullpath);e._oid=r.oid}return e._oid}}function Ge({ref:i="HEAD"}={}){const e=Object.create(null);return Object.defineProperty(e,Fr,{value:function({fs:t,gitdir:r,cache:n}){return new pf({fs:t,gitdir:r,ref:i,cache:n})}}),Object.freeze(e),e}class _f{constructor({fs:e,dir:t,gitdir:r,cache:n}){this.fs=e,this.cache=n,this.dir=t,this.gitdir=r,this.config=null;const a=this;this.ConstructEntry=class{constructor(o){this._fullpath=o,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(e){const t=e._fullpath,{fs:r,dir:n}=this,a=await r.readdir(M.join(n,t));return a===null?null:a.map(s=>M.join(t,s))}async type(e){return e._type===!1&&await e.stat(),e._type}async mode(e){return e._mode===!1&&await e.stat(),e._mode}async stat(e){if(e._stat===!1){const{fs:t,dir:r}=this;let n=await t.lstat(`${r}/${e._fullpath}`);if(!n)throw new Error(`ENOENT: no such file or directory, lstat '${e._fullpath}'`);let a=n.isDirectory()?"tree":"blob";a==="blob"&&!n.isFile()&&!n.isSymbolicLink()&&(a="special"),e._type=a,n=Nt(n),e._mode=n.mode,n.size===-1&&e._actualSize&&(n.size=e._actualSize),e._stat=n}return e._stat}async content(e){if(e._content===!1){const{fs:t,dir:r,gitdir:n}=this;if(await e.type()==="tree")e._content=void 0;else{const s=await(await this._getGitConfig(t,n)).get("core.autocrlf"),o=await t.read(`${r}/${e._fullpath}`,{autocrlf:s});e._actualSize=o.length,e._stat&&e._stat.size===-1&&(e._stat.size=e._actualSize),e._content=new Uint8Array(o)}}return e._content}async oid(e){if(e._oid===!1){const t=this,{fs:r,gitdir:n,cache:a}=this;let s;await Be.acquire({fs:r,gitdir:n,cache:a},async function(o){const c=o.entriesMap.get(e._fullpath),u=await e.stat(),d=await(await t._getGitConfig(r,n)).get("core.filemode"),h=typeof process<"u"?process.platform!=="win32":!0;if(!c||Or(u,c,d,h)){const w=await e.content();w===void 0?s=void 0:(s=await lt(Wt.wrap({type:"blob",object:w})),c&&s===c.oid&&(!d||u.mode===c.mode)&&Or(u,c,d,h)&&o.insert({filepath:e._fullpath,stats:u,oid:s}))}else s=c.oid}),e._oid=s}return e._oid}async _getGitConfig(e,t){return this.config?this.config:(this.config=await Oe.get({fs:e,gitdir:t}),this.config)}}function Vt(){const i=Object.create(null);return Object.defineProperty(i,Fr,{value:function({fs:e,dir:t,gitdir:r,cache:n}){return new _f({fs:e,dir:t,gitdir:r,cache:n})}}),Object.freeze(i),i}function gf(i,e){const t=e-i;return Array.from({length:t},(r,n)=>i+n)}const Ma=typeof Array.prototype.flat>"u"?i=>i.reduce((e,t)=>e.concat(t),[]):i=>i.flat();class vf{constructor(){this.value=null}consider(e){e!=null&&(this.value===null?this.value=e:e<this.value&&(this.value=e))}reset(){this.value=null}}function*bf(i){const e=new vf;let t;const r=[],n=i.length;for(let a=0;a<n;a++)r[a]=i[a].next().value,r[a]!==void 0&&e.consider(r[a]);if(e.value!==null)for(;;){const a=[];t=e.value,e.reset();for(let s=0;s<n;s++)r[s]!==void 0&&r[s]===t?(a[s]=r[s],r[s]=i[s].next().value):a[s]=null,r[s]!==void 0&&e.consider(r[s]);if(yield a,e.value===null)return}}async function vt({fs:i,cache:e,dir:t,gitdir:r,trees:n,map:a=async(c,u)=>u,reduce:s=async(c,u)=>{const f=Ma(u);return c!==void 0&&f.unshift(c),f},iterate:o=(c,u)=>Promise.all([...u].map(c))}){const c=n.map(w=>w[Fr]({fs:i,dir:t,gitdir:r,cache:e})),u=new Array(c.length).fill("."),f=gf(0,c.length),d=async w=>{f.map(b=>{const v=w[b];w[b]=v&&new c[b].ConstructEntry(v)});const y=(await Promise.all(f.map(b=>{const v=w[b];return v?c[b].readdir(v):[]}))).map(b=>(b===null?[]:b)[Symbol.iterator]());return{entries:w,children:bf(y)}},h=async w=>{const{entries:_,children:y}=await d(w),b=_.find(k=>k&&k._fullpath)._fullpath,v=await a(b,_);if(v!==null){let k=await o(h,y);return k=k.filter(S=>S!==void 0),s(v,k)}};return h(u)}async function Ui(i,e){const t=await i.readdir(e);t==null?await i.rm(e):t.length?await Promise.all(t.map(r=>{const n=M.join(e,r);return i.lstat(n).then(a=>{if(a)return a.isDirectory()?Ui(i,n):i.rm(n)})})).then(()=>i.rmdir(e)):await i.rmdir(e)}function yf(i){return kf(i)&&sa(i.then)&&sa(i.catch)}function kf(i){return i&&typeof i=="object"}function sa(i){return typeof i=="function"}function oa(i){return yf((t=>{try{return t.readFile().catch(r=>r)}catch(r){return r}})(i))}const ca=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function fa(i,e){if(oa(e))for(const t of ca)i[`_${t}`]=e[t].bind(e);else for(const t of ca)i[`_${t}`]=xi(e[t].bind(e));oa(e)?e.rm?i._rm=e.rm.bind(e):e.rmdir.length>1?i._rm=e.rmdir.bind(e):i._rm=Ui.bind(null,i):e.rm?i._rm=xi(e.rm.bind(e)):e.rmdir.length>2?i._rm=xi(e.rmdir.bind(e)):i._rm=Ui.bind(null,i)}class Q{constructor(e){if(typeof e._original_unwrapped_fs<"u")return e;const t=Object.getOwnPropertyDescriptor(e,"promises");t&&t.enumerable?fa(this,e.promises):fa(this,e),this._original_unwrapped_fs=e}async exists(e,t={}){try{return await this._stat(e),!0}catch(r){if(r.code==="ENOENT"||r.code==="ENOTDIR"||(r.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',r),r}}async read(e,t={}){try{let r=await this._readFile(e,t);if(t.autocrlf==="true")try{r=new TextDecoder("utf8",{fatal:!0}).decode(r),r=r.replace(/\r\n/g,`
`),r=new TextEncoder().encode(r)}catch{}return typeof r!="string"&&(r=Buffer.from(r)),r}catch{return null}}async write(e,t,r={}){try{await this._writeFile(e,t,r);return}catch{await this.mkdir(zt(e)),await this._writeFile(e,t,r)}}async mkdir(e,t=!1){try{await this._mkdir(e);return}catch(r){if(r===null||r.code==="EEXIST")return;if(t)throw r;if(r.code==="ENOENT"){const n=zt(e);if(n==="."||n==="/"||n===e)throw r;await this.mkdir(n),await this.mkdir(e,!0)}}}async rm(e){try{await this._unlink(e)}catch(t){if(t.code!=="ENOENT")throw t}}async rmdir(e,t){try{t&&t.recursive?await this._rm(e,t):await this._rmdir(e)}catch(r){if(r.code!=="ENOENT")throw r}}async readdir(e){try{const t=await this._readdir(e);return t.sort(Mr),t}catch(t){return t.code==="ENOTDIR"?null:[]}}async readdirDeep(e){const t=await this._readdir(e);return(await Promise.all(t.map(async n=>{const a=e+"/"+n;return(await this._stat(a)).isDirectory()?this.readdirDeep(a):a}))).reduce((n,a)=>n.concat(a),[])}async lstat(e){try{return await this._lstat(e)}catch(t){if(t.code==="ENOENT"||(t.code||"").includes("ENS"))return null;throw t}}async readlink(e,t={encoding:"buffer"}){try{const r=await this._readlink(e,t);return Buffer.isBuffer(r)?r:Buffer.from(r)}catch(r){if(r.code==="ENOENT"||(r.code||"").includes("ENS"))return null;throw r}}async writelink(e,t){return this._symlink(t.toString("utf8"),e)}}function T(i,e){if(e===void 0)throw new He(i)}async function Dr(i,e){return!i&&!e?!1:i&&!e||!i&&e?!0:!(await i.type()==="tree"&&await e.type()==="tree"||await i.type()===await e.type()&&await i.mode()===await e.mode()&&await i.oid()===await e.oid())}async function Fa({fs:i,dir:e,gitdir:t=M.join(e,".git"),commit:r="HEAD",cache:n={}}){try{T("fs",i),T("dir",e),T("gitdir",t);const a=new Q(i),s=[Ge({ref:r}),Vt(),At()];let o=[];await Be.acquire({fs:a,gitdir:t,cache:n},async function(u){o=u.unmergedPaths});const c=await vt({fs:a,cache:n,dir:e,gitdir:t,trees:s,map:async function(u,[f,d,h]){const w=!await Dr(d,h),_=o.includes(u),y=!await Dr(h,f);if(w||_)return f?{path:u,mode:await f.mode(),oid:await f.oid(),type:await f.type(),content:await f.content()}:void 0;if(y)return!1;throw new _r(u)}});await Be.acquire({fs:a,gitdir:t,cache:n},async function(u){for(const f of c)if(f!==!1){if(!f){await a.rmdir(`${e}/${f.path}`,{recursive:!0}),u.delete({filepath:f.path});continue}if(f.type==="blob"){const d=new TextDecoder().decode(f.content);await a.write(`${e}/${f.path}`,d,{mode:f.mode}),u.insert({filepath:f.path,oid:f.oid,stage:0})}}})}catch(a){throw a.caller="git.abortMerge",a}}class Jt{static async isIgnored({fs:e,dir:t,gitdir:r=M.join(t,".git"),filepath:n}){if(Ir(n)===".git")return!0;if(n===".")return!1;let a="";const s=M.join(r,"info","exclude");await e.exists(s)&&(a=await e.read(s,"utf8"));const o=[{gitignore:M.join(t,".gitignore"),filepath:n}],c=n.split("/").filter(Boolean);for(let f=1;f<c.length;f++){const d=c.slice(0,f).join("/"),h=c.slice(f).join("/");o.push({gitignore:M.join(t,d,".gitignore"),filepath:h})}let u=!1;for(const f of o){let d;try{d=await e.read(f.gitignore,"utf8")}catch(_){if(_.code==="NOENT")continue}const h=bc().add(a);h.add(d);const w=zt(f.filepath);if(w!=="."&&h.ignores(w))return!0;u?u=!h.test(f.filepath).unignored:u=h.test(f.filepath).ignored}return u}}async function xf({fs:i,gitdir:e,object:t,format:r,oid:n}){const a=`objects/${n.slice(0,2)}/${n.slice(2)}`,s=`${e}/${a}`;await i.exists(s)||await i.write(s,t)}let Bi=null;async function Ua(i){return Bi===null&&(Bi=Sf()),Bi?Ef(i):Wi.deflate(i)}async function Ef(i){const e=new CompressionStream("deflate"),t=new Blob([i]).stream().pipeThrough(e);return new Uint8Array(await new Response(t).arrayBuffer())}function Sf(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function Ze({fs:i,gitdir:e,type:t,object:r,format:n="content",oid:a=void 0,dryRun:s=!1}){return n!=="deflated"&&(n!=="wrapped"&&(r=Wt.wrap({type:t,object:r})),a=await lt(r),r=Buffer.from(await Ua(r))),s||await xf({fs:i,gitdir:e,object:r,format:"deflated",oid:a}),a}function La(i){let e;for(;~(e=i.indexOf(92));)i[e]=47;return i}async function Ha({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r,cache:n={},force:a=!1,parallel:s=!0}){try{T("fs",i),T("dir",e),T("gitdir",t),T("filepath",r);const o=new Q(i);await Be.acquire({fs:o,gitdir:t,cache:n},async c=>{const f=await(await Oe.get({fs:o,gitdir:t})).get("core.autocrlf");return Li({dir:e,gitdir:t,fs:o,filepath:r,index:c,force:a,parallel:s,autocrlf:f})})}catch(o){throw o.caller="git.add",o}}async function Li({dir:i,gitdir:e,fs:t,filepath:r,index:n,force:a,parallel:s,autocrlf:o}){r=Array.isArray(r)?r:[r];const c=r.map(async h=>{if(!a&&await Jt.isIgnored({fs:t,dir:i,gitdir:e,filepath:h}))return;const w=await t.lstat(M.join(i,h));if(!w)throw new be(h);if(w.isDirectory()){const _=await t.readdir(M.join(i,h));if(s){const y=_.map(b=>Li({dir:i,gitdir:e,fs:t,filepath:[M.join(h,b)],index:n,force:a,parallel:s,autocrlf:o}));await Promise.all(y)}else for(const y of _)await Li({dir:i,gitdir:e,fs:t,filepath:[M.join(h,y)],index:n,force:a,parallel:s,autocrlf:o})}else{const _=w.isSymbolicLink()?await t.readlink(M.join(i,h)).then(La):await t.read(M.join(i,h),{autocrlf:o});if(_===null)throw new be(h);const y=await Ze({fs:t,gitdir:e,type:"blob",object:_});n.insert({filepath:h,stats:w,oid:y})}}),u=await Promise.allSettled(c),f=u.filter(h=>h.status==="rejected").map(h=>h.reason);if(f.length>1)throw new dr(f);if(f.length===1)throw f[0];return u.filter(h=>h.status==="fulfilled"&&h.value).map(h=>h.value)}async function rr({fs:i,gitdir:e,path:t}){return(await Oe.get({fs:i,gitdir:e})).get(t)}function qa(i,...e){for(const t of e)if(t)for(const r of Object.keys(t)){const n=t[r];n!==void 0&&(i[r]=n)}return i}async function bt({fs:i,gitdir:e,author:t,commit:r}){const n=Math.floor(Date.now()/1e3),a={name:await rr({fs:i,gitdir:e,path:"user.name"}),email:await rr({fs:i,gitdir:e,path:"user.email"})||"",timestamp:n,timezoneOffset:new Date(n*1e3).getTimezoneOffset()},s=qa({},a,r?r.author:void 0,t);if(s.name!==void 0)return s}async function Ht({fs:i,gitdir:e,author:t,committer:r,commit:n}){const a=Math.floor(Date.now()/1e3),s={name:await rr({fs:i,gitdir:e,path:"user.name"}),email:await rr({fs:i,gitdir:e,path:"user.email"})||"",timestamp:a,timezoneOffset:new Date(a*1e3).getTimezoneOffset()},o=qa({},s,n?n.committer:void 0,t,r);if(o.name!==void 0)return o}async function Za({fs:i,cache:e,gitdir:t,oid:r}){const{type:n,object:a}=await xe({fs:i,cache:e,gitdir:t,oid:r});if(n==="tag")return r=Fe.from(a).parse().object,Za({fs:i,cache:e,gitdir:t,oid:r});if(n!=="commit")throw new Ue(r,n,"commit");return{commit:ke.from(a),oid:r}}async function qt({fs:i,cache:e,gitdir:t,oid:r}){const{commit:n,oid:a}=await Za({fs:i,cache:e,gitdir:t,oid:r});return{oid:a,commit:n.parse(),payload:n.withoutSignature()}}async function Ur({fs:i,cache:e,onSign:t,gitdir:r,message:n,author:a,committer:s,signingKey:o,amend:c=!1,dryRun:u=!1,noUpdateBranch:f=!1,ref:d,parent:h,tree:w}){let _=!1;d||(d=await G.resolve({fs:i,gitdir:r,ref:"HEAD",depth:2}));let y,b;try{y=await G.resolve({fs:i,gitdir:r,ref:d}),b=await qt({fs:i,gitdir:r,oid:y,cache:{}})}catch{_=!0}if(c&&_)throw new gr(d);const v=c?await bt({fs:i,gitdir:r,author:a,commit:b.commit}):await bt({fs:i,gitdir:r,author:a});if(!v)throw new ze("author");const k=c?await Ht({fs:i,gitdir:r,author:v,committer:s,commit:b.commit}):await Ht({fs:i,gitdir:r,author:v,committer:s});if(!k)throw new ze("committer");return Be.acquire({fs:i,gitdir:r,cache:e,allowUnmerged:!1},async function(S){const I=ja(S.entries).get(".");if(w||(w=await Ga({fs:i,gitdir:r,inode:I,dryRun:u})),h?h=await Promise.all(h.map(R=>G.resolve({fs:i,gitdir:r,ref:R}))):c?h=b.commit.parent:h=y?[y]:[],!n)if(c)n=b.commit.message;else throw new He("message");let A=ke.from({tree:w,parent:h,author:v,committer:k,message:n});o&&(A=await ke.sign(A,t,o));const x=await Ze({fs:i,gitdir:r,type:"commit",object:A.toObject(),dryRun:u});return!f&&!u&&await G.writeRef({fs:i,gitdir:r,ref:d,value:x}),x})}async function Ga({fs:i,gitdir:e,inode:t,dryRun:r}){const n=t.children;for(const c of n)c.type==="tree"&&(c.metadata.mode="040000",c.metadata.oid=await Ga({fs:i,gitdir:e,inode:c,dryRun:r}));const a=n.map(c=>({mode:c.metadata.mode,path:c.basename,oid:c.metadata.oid,type:c.type})),s=qe.from(a);return await Ze({fs:i,gitdir:e,type:"tree",object:s.toObject(),dryRun:r})}async function vr({fs:i,cache:e,gitdir:t,oid:r,filepath:n}){if(n.startsWith("/"))throw new gt("leading-slash");if(n.endsWith("/"))throw new gt("trailing-slash");const a=r,s=await Lt({fs:i,cache:e,gitdir:t,oid:r}),o=s.tree;if(n==="")r=s.oid;else{const c=n.split("/");r=await Wa({fs:i,cache:e,gitdir:t,tree:o,pathArray:c,oid:a,filepath:n})}return r}async function Wa({fs:i,cache:e,gitdir:t,tree:r,pathArray:n,oid:a,filepath:s}){const o=n.shift();for(const c of r)if(c.path===o){if(n.length===0)return c.oid;{const{type:u,object:f}=await xe({fs:i,cache:e,gitdir:t,oid:c.oid});if(u!=="tree")throw new Ue(a,u,"tree",s);return r=qe.from(f),Wa({fs:i,cache:e,gitdir:t,tree:r,pathArray:n,oid:a,filepath:s})}}throw new be(`file or directory found at "${a}:${s}"`)}async function Qt({fs:i,cache:e,gitdir:t,oid:r,filepath:n=void 0}){n!==void 0&&(r=await vr({fs:i,cache:e,gitdir:t,oid:r,filepath:n}));const{tree:a,oid:s}=await Lt({fs:i,cache:e,gitdir:t,oid:r});return{oid:s,tree:a.entries()}}async function br({fs:i,gitdir:e,tree:t}){const r=qe.from(t).toObject();return await Ze({fs:i,gitdir:e,type:"tree",object:r,format:"content"})}async function Rf({fs:i,cache:e,onSign:t,gitdir:r,ref:n,oid:a,note:s,force:o,author:c,committer:u,signingKey:f}){let d;try{d=await G.resolve({gitdir:r,fs:i,ref:n})}catch(v){if(!(v instanceof be))throw v}let w=(await Qt({fs:i,cache:e,gitdir:r,oid:d||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(o)w=w.filter(v=>v.path!==a);else for(const v of w)if(v.path===a)throw new et("note",a);typeof s=="string"&&(s=Buffer.from(s,"utf8"));const _=await Ze({fs:i,gitdir:r,type:"blob",object:s,format:"content"});w.push({mode:"100644",path:a,oid:_,type:"blob"});const y=await br({fs:i,gitdir:r,tree:w});return await Ur({fs:i,cache:e,onSign:t,gitdir:r,ref:n,tree:y,parent:d&&[d],message:`Note added by 'isomorphic-git addNote'
`,author:c,committer:u,signingKey:f})}async function Xa({fs:i,onSign:e,dir:t,gitdir:r=M.join(t,".git"),ref:n="refs/notes/commits",oid:a,note:s,force:o,author:c,committer:u,signingKey:f,cache:d={}}){try{T("fs",i),T("gitdir",r),T("oid",a),T("note",s),f&&T("onSign",e);const h=new Q(i),w=await bt({fs:h,gitdir:r,author:c});if(!w)throw new ze("author");const _=await Ht({fs:h,gitdir:r,author:w,committer:u});if(!_)throw new ze("committer");return await Rf({fs:new Q(h),cache:d,onSign:e,gitdir:r,ref:n,oid:a,note:s,force:o,author:w,committer:_,signingKey:f})}catch(h){throw h.caller="git.addNote",h}}async function Ka({fs:i,gitdir:e,remote:t,url:r,force:n}){if(t!==at.clean(t))throw new Qe(t,at.clean(t));const a=await Oe.get({fs:i,gitdir:e});if(!n&&(await a.getSubsections("remote")).includes(t)&&r!==await a.get(`remote.${t}.url`))throw new et("remote",t);await a.set(`remote.${t}.url`,r),await a.set(`remote.${t}.fetch`,`+refs/heads/*:refs/remotes/${t}/*`),await Oe.save({fs:i,gitdir:e,config:a})}async function Ya({fs:i,dir:e,gitdir:t=M.join(e,".git"),remote:r,url:n,force:a=!1}){try{return T("fs",i),T("gitdir",t),T("remote",r),T("url",n),await Ka({fs:new Q(i),gitdir:t,remote:r,url:n,force:a})}catch(s){throw s.caller="git.addRemote",s}}async function Tf({fs:i,cache:e,onSign:t,gitdir:r,ref:n,tagger:a,message:s=n,gpgsig:o,object:c,signingKey:u,force:f=!1}){if(n=n.startsWith("refs/tags/")?n:`refs/tags/${n}`,!f&&await G.exists({fs:i,gitdir:r,ref:n}))throw new et("tag",n);const d=await G.resolve({fs:i,gitdir:r,ref:c||"HEAD"}),{type:h}=await xe({fs:i,cache:e,gitdir:r,oid:d});let w=Fe.from({object:d,type:h,tag:n.replace("refs/tags/",""),tagger:a,message:s,gpgsig:o});u&&(w=await Fe.sign(w,t,u));const _=await Ze({fs:i,gitdir:r,type:"tag",object:w.toObject()});await G.writeRef({fs:i,gitdir:r,ref:n,value:_})}async function Va({fs:i,onSign:e,dir:t,gitdir:r=M.join(t,".git"),ref:n,tagger:a,message:s=n,gpgsig:o,object:c,signingKey:u,force:f=!1,cache:d={}}){try{T("fs",i),T("gitdir",r),T("ref",n),u&&T("onSign",e);const h=new Q(i),w=await bt({fs:h,gitdir:r,author:a});if(!w)throw new ze("tagger");return await Tf({fs:h,cache:d,onSign:e,gitdir:r,ref:n,tagger:w,message:s,gpgsig:o,object:c,signingKey:u,force:f})}catch(h){throw h.caller="git.annotatedTag",h}}async function $f({fs:i,gitdir:e,ref:t,object:r,checkout:n=!1,force:a=!1}){if(t!==at.clean(t))throw new Qe(t,at.clean(t));const s=`refs/heads/${t}`;if(!a&&await G.exists({fs:i,gitdir:e,ref:s}))throw new et("branch",t,!1);let o;try{o=await G.resolve({fs:i,gitdir:e,ref:r||"HEAD"})}catch{}o&&await G.writeRef({fs:i,gitdir:e,ref:s,value:o}),n&&await G.writeSymbolicRef({fs:i,gitdir:e,ref:"HEAD",value:s})}async function Ja({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,object:n,checkout:a=!1,force:s=!1}){try{return T("fs",i),T("gitdir",t),T("ref",r),await $f({fs:new Q(i),gitdir:t,ref:r,object:n,checkout:a,force:s})}catch(o){throw o.caller="git.branch",o}}const Qa=(i,e)=>i==="."||e==null||e.length===0||e==="."?!0:e.length>=i.length?e.startsWith(i):i.startsWith(e);async function Vi({fs:i,cache:e,onProgress:t,onPostCheckout:r,dir:n,gitdir:a,remote:s,ref:o,filepaths:c,noCheckout:u,noUpdateHead:f,dryRun:d,force:h,track:w=!0}){let _;if(r)try{_=await G.resolve({fs:i,gitdir:a,ref:"HEAD"})}catch{_="0000000000000000000000000000000000000000"}let y;try{y=await G.resolve({fs:i,gitdir:a,ref:o})}catch(b){if(o==="HEAD")throw b;const v=`${s}/${o}`;if(y=await G.resolve({fs:i,gitdir:a,ref:v}),w){const k=await Oe.get({fs:i,gitdir:a});await k.set(`branch.${o}.remote`,s),await k.set(`branch.${o}.merge`,`refs/heads/${o}`),await Oe.save({fs:i,gitdir:a,config:k})}await G.writeRef({fs:i,gitdir:a,ref:`refs/heads/${o}`,value:y})}if(!u){let b;try{b=await Af({fs:i,cache:e,onProgress:t,dir:n,gitdir:a,ref:o,force:h,filepaths:c})}catch(I){throw I instanceof be&&I.data.what===y?new cr(o,y):I}const v=b.filter(([I])=>I==="conflict").map(([I,A])=>A);if(v.length>0)throw new or(v);const k=b.filter(([I])=>I==="error").map(([I,A])=>A);if(k.length>0)throw new se(k.join(", "));if(d){r&&await r({previousHead:_,newHead:y,type:c!=null&&c.length>0?"file":"branch"});return}let S=0;const O=b.length;await Be.acquire({fs:i,gitdir:a,cache:e},async function(I){await Promise.all(b.filter(([A])=>A==="delete"||A==="delete-index").map(async function([A,x]){const R=`${n}/${x}`;A==="delete"&&await i.rm(R),I.delete({filepath:x}),t&&await t({phase:"Updating workdir",loaded:++S,total:O})}))}),await Be.acquire({fs:i,gitdir:a,cache:e},async function(I){for(const[A,x]of b)if(A==="rmdir"||A==="rmdir-index"){const R=`${n}/${x}`;try{A==="rmdir-index"&&I.delete({filepath:x}),await i.rmdir(R),t&&await t({phase:"Updating workdir",loaded:++S,total:O})}catch(D){if(D.code==="ENOTEMPTY")console.log(`Did not delete ${x} because directory is not empty`);else throw D}}}),await Promise.all(b.filter(([I])=>I==="mkdir"||I==="mkdir-index").map(async function([I,A]){const x=`${n}/${A}`;await i.mkdir(x),t&&await t({phase:"Updating workdir",loaded:++S,total:O})})),await Be.acquire({fs:i,gitdir:a,cache:e},async function(I){await Promise.all(b.filter(([A])=>A==="create"||A==="create-index"||A==="update"||A==="mkdir-index").map(async function([A,x,R,D,j]){const H=`${n}/${x}`;try{if(A!=="create-index"&&A!=="mkdir-index"){const{object:F}=await xe({fs:i,cache:e,gitdir:a,oid:R});if(j&&await i.rm(H),D===33188)await i.write(H,F);else if(D===33261)await i.write(H,F,{mode:511});else if(D===40960)await i.writelink(H,F);else throw new se(`Invalid mode 0o${D.toString(8)} detected in blob ${R}`)}const L=await i.lstat(H);D===33261&&(L.mode=493),A==="mkdir-index"&&(L.mode=57344),I.insert({filepath:x,stats:L,oid:R}),t&&await t({phase:"Updating workdir",loaded:++S,total:O})}catch(L){console.log(L)}}))}),r&&await r({previousHead:_,newHead:y,type:c!=null&&c.length>0?"file":"branch"})}if(!f){const b=await G.expand({fs:i,gitdir:a,ref:o});b.startsWith("refs/heads")?await G.writeSymbolicRef({fs:i,gitdir:a,ref:"HEAD",value:b}):await G.writeRef({fs:i,gitdir:a,ref:"HEAD",value:y})}}async function Af({fs:i,cache:e,onProgress:t,dir:r,gitdir:n,ref:a,force:s,filepaths:o}){let c=0;return vt({fs:i,cache:e,dir:r,gitdir:n,trees:[Ge({ref:a}),Vt(),At()],map:async function(u,[f,d,h]){if(u===".")return;if(o&&!o.some(_=>Qa(u,_)))return null;switch(t&&await t({phase:"Analyzing workdir",loaded:++c}),[!!h,!!f,!!d].map(Number).join("")){case"000":return;case"001":return s&&o&&o.includes(u)?["delete",u]:void 0;case"010":switch(await f.type()){case"tree":return["mkdir",u];case"blob":return["create",u,await f.oid(),await f.mode()];case"commit":return["mkdir-index",u,await f.oid(),await f.mode()];default:return["error",`new entry Unhandled type ${await f.type()}`]}case"011":switch(`${await f.type()}-${await d.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",u];case"blob-blob":return await f.oid()!==await d.oid()?s?["update",u,await f.oid(),await f.mode(),await f.mode()!==await d.mode()]:["conflict",u]:await f.mode()!==await d.mode()?s?["update",u,await f.oid(),await f.mode(),!0]:["conflict",u]:["create-index",u,await f.oid(),await f.mode()];case"commit-tree":return;case"commit-blob":return["conflict",u];default:return["error",`new entry Unhandled type ${f.type}`]}case"100":return["delete-index",u];case"101":switch(await h.type()){case"tree":return["rmdir",u];case"blob":return await h.oid()!==await d.oid()?s?["delete",u]:["conflict",u]:["delete",u];case"commit":return["rmdir-index",u];default:return["error",`delete entry Unhandled type ${await h.type()}`]}case"110":case"111":switch(`${await h.type()}-${await f.type()}`){case"tree-tree":return;case"blob-blob":{if(await h.oid()===await f.oid()&&await h.mode()===await f.mode()&&!s)return;if(d){if(await d.oid()!==await h.oid()&&await d.oid()!==await f.oid())return s?["update",u,await f.oid(),await f.mode(),await f.mode()!==await d.mode()]:["conflict",u]}else if(s)return["update",u,await f.oid(),await f.mode(),await f.mode()!==await h.mode()];return await f.mode()!==await h.mode()?["update",u,await f.oid(),await f.mode(),!0]:await f.oid()!==await h.oid()?["update",u,await f.oid(),await f.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",u,await f.oid()];case"blob-tree":return["update-blob-to-tree",u];case"commit-commit":return["mkdir-index",u,await f.oid(),await f.mode()];default:return["error",`update entry Unhandled type ${await h.type()}-${await f.type()}`]}}},reduce:async function(u,f){return f=Ma(f),u?u&&u[0]==="rmdir"?(f.push(u),f):(f.unshift(u),f):f}})}async function Ji({fs:i,onProgress:e,onPostCheckout:t,dir:r,gitdir:n=M.join(r,".git"),remote:a="origin",ref:s,filepaths:o,noCheckout:c=!1,noUpdateHead:u=s===void 0,dryRun:f=!1,force:d=!1,track:h=!0,cache:w={}}){try{T("fs",i),T("dir",r),T("gitdir",n);const _=s||"HEAD";return await Vi({fs:new Q(i),cache:w,onProgress:e,onPostCheckout:t,dir:r,gitdir:n,remote:a,ref:_,filepaths:o,noCheckout:c,noUpdateHead:u,dryRun:f,force:d,track:h})}catch(_){throw _.caller="git.checkout",_}}const Of=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function Tt(i){const e=Of.exec(i);return e?e[1]==="remotes/"&&i.endsWith("/HEAD")?e[2].slice(0,-5):e[2]:i}async function kt({fs:i,gitdir:e,fullname:t=!1,test:r=!1}){const n=await G.resolve({fs:i,gitdir:e,ref:"HEAD",depth:2});if(r)try{await G.resolve({fs:i,gitdir:e,ref:n})}catch{return}if(n.startsWith("refs/"))return t?n:Tt(n)}function If(i){return i=i.replace(/^git@([^:]+):/,"https://$1/"),i=i.replace(/^ssh:\/\//,"https://"),i}function es({username:i="",password:e=""}){return`Basic ${Buffer.from(`${i}:${e}`).toString("base64")}`}async function yr(i,e){const t=Da(i);for(;;){const{value:r,done:n}=await t.next();if(r&&await e(r),n)break}t.return&&t.return()}async function Pr(i){let e=0;const t=[];await yr(i,a=>{t.push(a),e+=a.byteLength});const r=new Uint8Array(e);let n=0;for(const a of t)r.set(a,n),n+=a.byteLength;return r}function la(i){let e=i.match(/^https?:\/\/([^/]+)@/);if(e==null)return{url:i,auth:{}};e=e[1];const[t,r]=e.split(":");return i=i.replace(`${e}@`,""),{url:i,auth:{username:t,password:r}}}function Hi(i,e){const t=e.toString(16);return"0".repeat(i-t.length)+t}class Te{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(e){typeof e=="string"&&(e=Buffer.from(e));const t=e.length+4,r=Hi(4,t);return Buffer.concat([Buffer.from(r,"utf8"),e])}static streamReader(e){const t=new Pa(e);return async function(){try{let n=await t.read(4);if(n==null)return!0;if(n=parseInt(n.toString("utf8"),16),n===0||n===1)return null;const a=await t.read(n-4);return a??!0}catch(n){return e.error=n,!0}}}}async function ua(i){const e={};let t;for(;t=await i(),t!==!0;){if(t===null)continue;t=t.toString("utf8").replace(/\n$/,"");const r=t.indexOf("=");if(r>-1){const n=t.slice(0,r),a=t.slice(r+1);e[n]=a}else e[t]=!0}return{protocolVersion:2,capabilities2:e}}async function ha(i,{service:e}){const t=new Set,r=new Map,n=new Map,a=Te.streamReader(i);let s=await a();for(;s===null;)s=await a();if(s===!0)throw new fr;if(s.includes("version 2"))return ua(a);if(s.toString("utf8").replace(/\n$/,"")!==`# service=${e}`)throw new Ot(`# service=${e}\\n`,s.toString("utf8"));let o=await a();for(;o===null;)o=await a();if(o===!0)return{capabilities:t,refs:r,symrefs:n};if(o=o.toString("utf8"),o.includes("version 2"))return ua(a);const[c,u]=Ci(o,"\0","\\x00");if(u.split(" ").map(f=>t.add(f)),c!=="0000000000000000000000000000000000000000 capabilities^{}"){const[f,d]=Ci(c," "," ");for(r.set(d,f);;){const h=await a();if(h===!0)break;if(h!==null){const[w,_]=Ci(h.toString("utf8")," "," ");r.set(_,w)}}}for(const f of t)if(f.startsWith("symref=")){const d=f.match(/symref=([^:]+):(.*)/);d.length===3&&n.set(d[1],d[2])}return{protocolVersion:1,capabilities:t,refs:r,symrefs:n}}function Ci(i,e,t){const r=i.trim().split(e);if(r.length!==2)throw new Ot(`Two strings separated by '${t}'`,i.toString("utf8"));return r}const da=(i,e)=>i.endsWith("?")?`${i}${e}`:`${i}/${e.replace(/^https?:\/\//,"")}`,wa=(i,e)=>{(e.username||e.password)&&(i.Authorization=es(e)),e.headers&&Object.assign(i,e.headers)},Di=async i=>{try{const e=Buffer.from(await Pr(i.body)),t=e.toString("utf8");return{preview:t.length<256?t:t.slice(0,256)+"...",response:t,data:e}}catch{return{}}};class Nr{static async capabilities(){return["discover","connect"]}static async discover({http:e,onProgress:t,onAuth:r,onAuthSuccess:n,onAuthFailure:a,corsProxy:s,service:o,url:c,headers:u,protocolVersion:f}){let{url:d,auth:h}=la(c);const w=s?da(s,d):d;(h.username||h.password)&&(u.Authorization=es(h)),f===2&&(u["Git-Protocol"]="version=2");let _,y,b=!1;do if(_=await e.request({onProgress:t,method:"GET",url:`${w}/info/refs?service=${o}`,headers:u}),y=!1,_.statusCode===401||_.statusCode===203){const v=b?a:r;if(v){if(h=await v(d,{...h,headers:{...u}}),h&&h.cancel)throw new Yt;h&&(wa(u,h),b=!0,y=!0)}}else _.statusCode===200&&b&&n&&await n(d,h);while(y);if(_.statusCode!==200){const{response:v}=await Di(_);throw new Ft(_.statusCode,_.statusMessage,v)}if(_.headers["content-type"]===`application/x-${o}-advertisement`){const v=await ha(_.body,{service:o});return v.auth=h,v}else{const{preview:v,response:k,data:S}=await Di(_);try{const O=await ha([S],{service:o});return O.auth=h,O}catch{throw new wr(v,k)}}}static async connect({http:e,onProgress:t,corsProxy:r,service:n,url:a,auth:s,body:o,headers:c}){const u=la(a);u&&(a=u.url),r&&(a=da(r,a)),c["content-type"]=`application/x-${n}-request`,c.accept=`application/x-${n}-result`,wa(c,s);const f=await e.request({onProgress:t,method:"POST",url:`${a}/${n}`,body:o,headers:c});if(f.statusCode!==200){const{response:d}=Di(f);throw new Ft(f.statusCode,f.statusMessage,d)}return f}}function jf({url:i}){if(i.startsWith("git@"))return{transport:"ssh",address:i};const e=i.match(/(\w+)(:\/\/|::)(.*)/);if(e!==null){if(e[2]==="://")return{transport:e[1],address:e[0]};if(e[2]==="::")return{transport:e[1],address:e[3]}}}class Lr{static getRemoteHelperFor({url:e}){const t=new Map;t.set("http",Nr),t.set("https",Nr);const r=jf({url:e});if(!r)throw new pr(e);if(t.has(r.transport))return t.get(r.transport);throw new mr(e,r.transport,r.transport==="ssh"?If(e):void 0)}}let St=null;class ir{static async read({fs:e,gitdir:t}){St===null&&(St=new tr);const r=M.join(t,"shallow"),n=new Set;return await St.acquire(r,async function(){const a=await e.read(r,{encoding:"utf8"});if(a===null||a.trim()==="")return n;a.trim().split(`
`).map(s=>n.add(s))}),n}static async write({fs:e,gitdir:t,oids:r}){St===null&&(St=new tr);const n=M.join(t,"shallow");if(r.size>0){const a=[...r].join(`
`)+`
`;await St.acquire(n,async function(){await e.write(n,a,{encoding:"utf8"})})}else await St.acquire(n,async function(){await e.rm(n)})}}async function Bf({fs:i,gitdir:e,oid:t}){const r=`objects/${t.slice(0,2)}/${t.slice(2)}`;return i.exists(`${e}/${r}`)}async function Cf({fs:i,cache:e,gitdir:t,oid:r,getExternalRefDelta:n}){let a=await i.readdir(M.join(t,"objects/pack"));a=a.filter(s=>s.endsWith(".idx"));for(const s of a){const o=`${t}/objects/pack/${s}`,c=await Yi({fs:i,cache:e,filename:o,getExternalRefDelta:n});if(c.error)throw new se(c.error);if(c.offsets.has(r))return!0}return!1}async function ma({fs:i,cache:e,gitdir:t,oid:r,format:n="content"}){const a=o=>xe({fs:i,cache:e,gitdir:t,oid:o});let s=await Bf({fs:i,gitdir:t,oid:r});return s||(s=await Cf({fs:i,cache:e,gitdir:t,oid:r,getExternalRefDelta:a})),s}function Df(i){const n="5041434b"+"00000002"+"00000000";return i.slice(0,12).toString("hex")===n}function ts(i,e){const t=i.map(r=>r.split("=",1)[0]);return e.filter(r=>{const n=r.split("=",1)[0];return t.includes(n)})}const Hr={name:"isomorphic-git",version:"1.30.1",agent:"git/isomorphic-git@1.30.1"};class $r{constructor(){this._queue=[]}write(e){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const t=this._waiting;this._waiting=null,t({value:e})}else this._queue.push(e)}end(){if(this._ended=!0,this._waiting){const e=this._waiting;this._waiting=null,e({done:!0})}}destroy(e){this.error=e,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(e=>{this._waiting=e})}}function Pf(i){const e=i.indexOf("\r"),t=i.indexOf(`
`);return e===-1&&t===-1?-1:e===-1?t+1:t===-1?e+1:t===e+1?t+1:Math.min(e,t)+1}function rs(i){const e=new $r;let t="";return(async()=>(await yr(i,r=>{for(r=r.toString("utf8"),t+=r;;){const n=Pf(t);if(n===-1)break;e.write(t.slice(0,n)),t=t.slice(n)}}),t.length>0&&e.write(t),e.end()))(),e}class is{static demux(e){const t=Te.streamReader(e),r=new $r,n=new $r,a=new $r,s=async function(){const o=await t();if(o===null)return s();if(o===!0){r.end(),a.end(),e.error?n.destroy(e.error):n.end();return}switch(o[0]){case 1:{n.write(o.slice(1));break}case 2:{a.write(o.slice(1));break}case 3:{const c=o.slice(1);a.write(c),r.end(),a.end(),n.destroy(new Error(c.toString("utf8")));return}default:r.write(o)}s()};return s(),{packetlines:r,packfile:n,progress:a}}}async function Nf(i){const{packetlines:e,packfile:t,progress:r}=is.demux(i),n=[],a=[],s=[];let o=!1,c=!1;return new Promise((u,f)=>{yr(e,d=>{const h=d.toString("utf8").trim();if(h.startsWith("shallow")){const w=h.slice(-41).trim();w.length!==40&&f(new _t(w)),n.push(w)}else if(h.startsWith("unshallow")){const w=h.slice(-41).trim();w.length!==40&&f(new _t(w)),a.push(w)}else if(h.startsWith("ACK")){const[,w,_]=h.split(" ");s.push({oid:w,status:_}),_||(c=!0)}else h.startsWith("NAK")?(o=!0,c=!0):(c=!0,o=!0);c&&(i.error?f(i.error):u({shallows:n,unshallows:a,acks:s,nak:o,packfile:t,progress:r}))}).finally(()=>{c||(i.error?f(i.error):u({shallows:n,unshallows:a,acks:s,nak:o,packfile:t,progress:r}))})})}function zf({capabilities:i=[],wants:e=[],haves:t=[],shallows:r=[],depth:n=null,since:a=null,exclude:s=[]}){const o=[];e=[...new Set(e)];let c=` ${i.join(" ")}`;for(const u of e)o.push(Te.encode(`want ${u}${c}
`)),c="";for(const u of r)o.push(Te.encode(`shallow ${u}
`));n!==null&&o.push(Te.encode(`deepen ${n}
`)),a!==null&&o.push(Te.encode(`deepen-since ${Math.floor(a.valueOf()/1e3)}
`));for(const u of s)o.push(Te.encode(`deepen-not ${u}
`));o.push(Te.flush());for(const u of t)o.push(Te.encode(`have ${u}
`));return o.push(Te.encode(`done
`)),o}async function Qi({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,gitdir:c,ref:u,remoteRef:f,remote:d,url:h,corsProxy:w,depth:_=null,since:y=null,exclude:b=[],relative:v=!1,tags:k=!1,singleBranch:S=!1,headers:O={},prune:I=!1,pruneTags:A=!1}){const x=u||await kt({fs:i,gitdir:c,test:!0}),R=await Oe.get({fs:i,gitdir:c}),D=d||x&&await R.get(`branch.${x}.remote`)||"origin",j=h||await R.get(`remote.${D}.url`);if(typeof j>"u")throw new He("remote OR url");const H=f||x&&await R.get(`branch.${x}.merge`)||u||"HEAD";w===void 0&&(w=await R.get("http.corsProxy"));const L=Lr.getRemoteHelperFor({url:j}),F=await L.discover({http:t,onAuth:a,onAuthSuccess:s,onAuthFailure:o,corsProxy:w,service:"git-upload-pack",url:j,headers:O,protocolVersion:1}),K=F.auth,ce=F.refs;if(ce.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(_!==null&&!F.capabilities.has("shallow"))throw new pt("shallow","depth");if(y!==null&&!F.capabilities.has("deepen-since"))throw new pt("deepen-since","since");if(b.length>0&&!F.capabilities.has("deepen-not"))throw new pt("deepen-not","exclude");if(v===!0&&!F.capabilities.has("deepen-relative"))throw new pt("deepen-relative","relative");const{oid:ge,fullref:N}=G.resolveAgainstMap({ref:H,map:ce});for(const te of ce.keys())te===N||te==="HEAD"||te.startsWith("refs/heads/")||k&&te.startsWith("refs/tags/")||ce.delete(te);const U=ts([...F.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Hr.agent}`]);v&&U.push("deepen-relative");const X=S?[ge]:ce.values(),ae=S?[x]:await G.listRefs({fs:i,gitdir:c,filepath:"refs"});let ie=[];for(let te of ae)try{te=await G.expand({fs:i,gitdir:c,ref:te});const _e=await G.resolve({fs:i,gitdir:c,ref:te});await ma({fs:i,cache:e,gitdir:c,oid:_e})&&ie.push(_e)}catch{}ie=[...new Set(ie)];const re=await ir.read({fs:i,gitdir:c}),le=F.capabilities.has("shallow")?[...re]:[],we=zf({capabilities:U,wants:X,haves:ie,shallows:le,depth:_,since:y,exclude:b}),ye=Buffer.from(await Pr(we)),ue=await L.connect({http:t,onProgress:r,corsProxy:w,service:"git-upload-pack",url:j,auth:K,body:[ye],headers:O}),oe=await Nf(ue.body);ue.headers&&(oe.headers=ue.headers);for(const te of oe.shallows)if(!re.has(te))try{const{object:_e}=await xe({fs:i,cache:e,gitdir:c,oid:te}),$e=new ke(_e),Ee=await Promise.all($e.headers().parent.map(ve=>ma({fs:i,cache:e,gitdir:c,oid:ve})));Ee.length===0||Ee.every(ve=>ve)||re.add(te)}catch{re.add(te)}for(const te of oe.unshallows)re.delete(te);if(await ir.write({fs:i,gitdir:c,oids:re}),S){const te=new Map([[N,ge]]),_e=new Map;let $e=10,Ee=N;for(;$e--;){const fe=F.symrefs.get(Ee);if(fe===void 0)break;_e.set(Ee,fe),Ee=fe}const Ce=ce.get(Ee);Ce&&te.set(Ee,Ce);const{pruned:ve}=await G.updateRemoteRefs({fs:i,gitdir:c,remote:D,refs:te,symrefs:_e,tags:k,prune:I});I&&(oe.pruned=ve)}else{const{pruned:te}=await G.updateRemoteRefs({fs:i,gitdir:c,remote:D,refs:ce,symrefs:F.symrefs,tags:k,prune:I,pruneTags:A});I&&(oe.pruned=te)}if(oe.HEAD=F.symrefs.get("HEAD"),oe.HEAD===void 0){const{oid:te}=G.resolveAgainstMap({ref:"HEAD",map:ce});for(const[_e,$e]of ce.entries())if(_e!=="HEAD"&&$e===te){oe.HEAD=_e;break}}const pe=N.startsWith("refs/tags")?"tag":"branch";if(oe.FETCH_HEAD={oid:ge,description:`${pe} '${Tt(N)}' of ${j}`},r||n){const te=rs(oe.progress);yr(te,async _e=>{if(n&&await n(_e),r){const $e=_e.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);$e&&await r({phase:$e[1].trim(),loaded:parseInt($e[2],10),total:parseInt($e[3],10)})}})}const Re=Buffer.from(await Pr(oe.packfile));if(ue.body.error)throw ue.body.error;const Me=Re.slice(-20).toString("hex"),je={defaultBranch:oe.HEAD,fetchHead:oe.FETCH_HEAD.oid,fetchHeadDescription:oe.FETCH_HEAD.description};if(oe.headers&&(je.headers=oe.headers),I&&(je.pruned=oe.pruned),Me!==""&&!Df(Re)){je.packfile=`objects/pack/pack-${Me}.pack`;const te=M.join(c,je.packfile);await i.write(te,Re);const _e=Ee=>xe({fs:i,cache:e,gitdir:c,oid:Ee}),$e=await Mt.fromPack({pack:Re,getExternalRefDelta:_e,onProgress:r});await i.write(te.replace(/\.pack$/,".idx"),await $e.toBuffer())}return je}async function ns({fs:i,bare:e=!1,dir:t,gitdir:r=e?t:M.join(t,".git"),defaultBranch:n="master"}){if(await i.exists(r+"/config"))return;let a=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];a=a.map(s=>r+"/"+s);for(const s of a)await i.mkdir(s);await i.write(r+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${e}
`+(e?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await i.write(r+"/HEAD",`ref: refs/heads/${n}
`)}async function Mf({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,onPostCheckout:c,dir:u,gitdir:f,url:d,corsProxy:h,ref:w,remote:_,depth:y,since:b,exclude:v,relative:k,singleBranch:S,noCheckout:O,noTags:I,headers:A}){try{if(await ns({fs:i,gitdir:f}),await Ka({fs:i,gitdir:f,remote:_,url:d,force:!1}),h){const D=await Oe.get({fs:i,gitdir:f});await D.set("http.corsProxy",h),await Oe.save({fs:i,gitdir:f,config:D})}const{defaultBranch:x,fetchHead:R}=await Qi({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,gitdir:f,ref:w,remote:_,corsProxy:h,depth:y,since:b,exclude:v,relative:k,singleBranch:S,headers:A,tags:!I});if(R===null)return;w=w||x,w=w.replace("refs/heads/",""),await Vi({fs:i,cache:e,onProgress:r,onPostCheckout:c,dir:u,gitdir:f,ref:w,remote:_,noCheckout:O})}catch(x){throw await i.rmdir(f,{recursive:!0,maxRetries:10}).catch(()=>{}),x}}async function en({fs:i,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,onPostCheckout:o,dir:c,gitdir:u=M.join(c,".git"),url:f,corsProxy:d=void 0,ref:h=void 0,remote:w="origin",depth:_=void 0,since:y=void 0,exclude:b=[],relative:v=!1,singleBranch:k=!1,noCheckout:S=!1,noTags:O=!1,headers:I={},cache:A={}}){try{return T("fs",i),T("http",e),T("gitdir",u),S||T("dir",c),T("url",f),await Mf({fs:new Q(i),cache:A,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,onPostCheckout:o,dir:c,gitdir:u,url:f,corsProxy:d,ref:h,remote:w,depth:_,since:y,exclude:b,relative:v,singleBranch:k,noCheckout:S,noTags:O,headers:I})}catch(x){throw x.caller="git.clone",x}}async function as({fs:i,onSign:e,dir:t,gitdir:r=M.join(t,".git"),message:n,author:a,committer:s,signingKey:o,amend:c=!1,dryRun:u=!1,noUpdateBranch:f=!1,ref:d,parent:h,tree:w,cache:_={}}){try{T("fs",i),c||T("message",n),o&&T("onSign",e);const y=new Q(i);return await Ur({fs:y,cache:_,onSign:e,gitdir:r,message:n,author:a,committer:s,signingKey:o,amend:c,dryRun:u,noUpdateBranch:f,ref:d,parent:h,tree:w})}catch(y){throw y.caller="git.commit",y}}async function ss({fs:i,dir:e,gitdir:t=M.join(e,".git"),fullname:r=!1,test:n=!1}){try{return T("fs",i),T("gitdir",t),await kt({fs:new Q(i),gitdir:t,fullname:r,test:n})}catch(a){throw a.caller="git.currentBranch",a}}async function Ff({fs:i,gitdir:e,ref:t}){if(t=t.startsWith("refs/heads/")?t:`refs/heads/${t}`,!await G.exists({fs:i,gitdir:e,ref:t}))throw new be(t);const n=await G.expand({fs:i,gitdir:e,ref:t}),a=await kt({fs:i,gitdir:e,fullname:!0});if(n===a){const c=await G.resolve({fs:i,gitdir:e,ref:n});await G.writeRef({fs:i,gitdir:e,ref:"HEAD",value:c})}await G.deleteRef({fs:i,gitdir:e,ref:n});const s=Tt(t),o=await Oe.get({fs:i,gitdir:e});await o.deleteSection("branch",s),await Oe.save({fs:i,gitdir:e,config:o})}async function os({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r}){try{return T("fs",i),T("ref",r),await Ff({fs:new Q(i),gitdir:t,ref:r})}catch(n){throw n.caller="git.deleteBranch",n}}async function cs({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r}){try{T("fs",i),T("ref",r),await G.deleteRef({fs:new Q(i),gitdir:t,ref:r})}catch(n){throw n.caller="git.deleteRef",n}}async function Uf({fs:i,gitdir:e,remote:t}){const r=await Oe.get({fs:i,gitdir:e});await r.deleteSection("remote",t),await Oe.save({fs:i,gitdir:e,config:r})}async function fs({fs:i,dir:e,gitdir:t=M.join(e,".git"),remote:r}){try{return T("fs",i),T("remote",r),await Uf({fs:new Q(i),gitdir:t,remote:r})}catch(n){throw n.caller="git.deleteRemote",n}}async function Lf({fs:i,gitdir:e,ref:t}){t=t.startsWith("refs/tags/")?t:`refs/tags/${t}`,await G.deleteRef({fs:i,gitdir:e,ref:t})}async function ls({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r}){try{return T("fs",i),T("ref",r),await Lf({fs:new Q(i),gitdir:t,ref:r})}catch(n){throw n.caller="git.deleteTag",n}}async function Hf({fs:i,gitdir:e,oid:t}){const r=t.slice(0,2);return(await i.readdir(`${e}/objects/${r}`)).map(a=>`${r}${a}`).filter(a=>a.startsWith(t))}async function qf({fs:i,cache:e,gitdir:t,oid:r,getExternalRefDelta:n}){const a=[];let s=await i.readdir(M.join(t,"objects/pack"));s=s.filter(o=>o.endsWith(".idx"));for(const o of s){const c=`${t}/objects/pack/${o}`,u=await Yi({fs:i,cache:e,filename:c,getExternalRefDelta:n});if(u.error)throw new se(u.error);for(const f of u.offsets.keys())f.startsWith(r)&&a.push(f)}return a}async function Zf({fs:i,cache:e,gitdir:t,oid:r}){const n=o=>xe({fs:i,cache:e,gitdir:t,oid:o}),a=await Hf({fs:i,gitdir:t,oid:r}),s=await qf({fs:i,cache:e,gitdir:t,oid:r,getExternalRefDelta:n});for(const o of s)a.indexOf(o)===-1&&a.push(o);if(a.length===1)return a[0];throw a.length>1?new sr("oids",r,a):new be(`an object matching "${r}"`)}async function us({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,cache:n={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),await Zf({fs:new Q(i),cache:n,gitdir:t,oid:r})}catch(a){throw a.caller="git.expandOid",a}}async function hs({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r}){try{return T("fs",i),T("gitdir",t),T("ref",r),await G.expand({fs:new Q(i),gitdir:t,ref:r})}catch(n){throw n.caller="git.expandRef",n}}async function tn({fs:i,cache:e,gitdir:t,oids:r}){const n={},a=r.length;let s=r.map((o,c)=>({index:c,oid:o}));for(;s.length;){const o=new Set;for(const{oid:u,index:f}of s)n[u]||(n[u]=new Set),n[u].add(f),n[u].size===a&&o.add(u);if(o.size>0)return[...o];const c=new Map;for(const{oid:u,index:f}of s)try{const{object:d}=await xe({fs:i,cache:e,gitdir:t,oid:u}),h=ke.from(d),{parent:w}=h.parseHeaders();for(const _ of w)(!n[_]||!n[_].has(f))&&c.set(_+":"+f,{oid:_,index:f})}catch{}s=Array.from(c.values())}return[]}const Pi=/^.*(\r?\n|$)/gm;function Gf({branches:i,contents:e}){const t=i[1],r=i[2],n=e[0],a=e[1],s=e[2],o=a.match(Pi),c=n.match(Pi),u=s.match(Pi),f=Rc(o,c,u),d=7;let h="",w=!0;for(const _ of f)_.ok&&(h+=_.ok.join("")),_.conflict&&(w=!1,h+=`${"<".repeat(d)} ${t}
`,h+=_.conflict.a.join(""),h+=`${"=".repeat(d)}
`,h+=_.conflict.b.join(""),h+=`${">".repeat(d)} ${r}
`);return{cleanMerge:w,mergedText:h}}async function Wf({fs:i,cache:e,dir:t,gitdir:r=M.join(t,".git"),index:n,ourOid:a,baseOid:s,theirOid:o,ourName:c="ours",baseName:u="base",theirName:f="theirs",dryRun:d=!1,abortOnConflict:h=!0,mergeDriver:w}){const _=Ge({ref:a}),y=Ge({ref:s}),b=Ge({ref:o}),v=[],k=[],S=[],O=[],I=await vt({fs:i,cache:e,dir:t,gitdir:r,trees:[_,y,b],map:async function(A,[x,R,D]){const j=Ir(A),H=await Dr(x,R),L=await Dr(D,R);switch(`${H}-${L}`){case"false-false":return{mode:await R.mode(),path:j,oid:await R.oid(),type:await R.type()};case"false-true":return D?{mode:await D.mode(),path:j,oid:await D.oid(),type:await D.type()}:void 0;case"true-false":return x?{mode:await x.mode(),path:j,oid:await x.oid(),type:await x.type()}:void 0;case"true-true":{if(x&&R&&D&&await x.type()==="blob"&&await R.type()==="blob"&&await D.type()==="blob")return Xf({fs:i,gitdir:r,path:j,ours:x,base:R,theirs:D,ourName:c,baseName:u,theirName:f,mergeDriver:w}).then(async F=>{if(F.cleanMerge)h||n.insert({filepath:A,oid:F.mergeResult.oid,stage:0});else if(v.push(A),k.push(A),!h){const K=await R.oid(),ce=await x.oid(),ge=await D.oid();n.delete({filepath:A}),n.insert({filepath:A,oid:K,stage:1}),n.insert({filepath:A,oid:ce,stage:2}),n.insert({filepath:A,oid:ge,stage:3})}return F.mergeResult});if(R&&!x&&D&&await R.type()==="blob"&&await D.type()==="blob"){if(v.push(A),S.push(A),!h){const F=await R.oid(),K=await D.oid();n.delete({filepath:A}),n.insert({filepath:A,oid:F,stage:1}),n.insert({filepath:A,oid:K,stage:3})}return{mode:await D.mode(),oid:await D.oid(),type:"blob",path:j}}if(R&&x&&!D&&await R.type()==="blob"&&await x.type()==="blob"){if(v.push(A),O.push(A),!h){const F=await R.oid(),K=await x.oid();n.delete({filepath:A}),n.insert({filepath:A,oid:F,stage:1}),n.insert({filepath:A,oid:K,stage:2})}return{mode:await x.mode(),oid:await x.oid(),type:"blob",path:j}}if(R&&!x&&!D&&await R.type()==="blob")return;throw new Xt}}},reduce:v.length!==0&&(!t||h)?void 0:async(A,x)=>{const R=x.filter(Boolean);if(A&&!(A&&A.type==="tree"&&R.length===0)){if(R.length>0){const j=new qe(R).toObject(),H=await Ze({fs:i,gitdir:r,type:"tree",object:j,dryRun:d});A.oid=H}return A}}});return v.length!==0?(t&&!h&&await vt({fs:i,cache:e,dir:t,gitdir:r,trees:[Ge({ref:I.oid})],map:async function(A,[x]){const R=`${t}/${A}`;if(await x.type()==="blob"){const D=await x.mode(),j=new TextDecoder().decode(await x.content());await i.write(R,j,{mode:D})}return!0}}),new Kt(v,k,S,O)):I.oid}async function Xf({fs:i,gitdir:e,path:t,ours:r,base:n,theirs:a,ourName:s,theirName:o,baseName:c,dryRun:u,mergeDriver:f=Gf}){const d="blob",h=await n.mode()===await r.mode()?await a.mode():await r.mode();if(await r.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:h,path:t,oid:await r.oid(),type:d}};if(await r.oid()===await n.oid())return{cleanMerge:!0,mergeResult:{mode:h,path:t,oid:await a.oid(),type:d}};if(await a.oid()===await n.oid())return{cleanMerge:!0,mergeResult:{mode:h,path:t,oid:await r.oid(),type:d}};const w=Buffer.from(await r.content()).toString("utf8"),_=Buffer.from(await n.content()).toString("utf8"),y=Buffer.from(await a.content()).toString("utf8"),{mergedText:b,cleanMerge:v}=await f({branches:[c,s,o],contents:[_,w,y],path:t}),k=await Ze({fs:i,gitdir:e,type:"blob",object:Buffer.from(b,"utf8"),dryRun:u});return{cleanMerge:v,mergeResult:{mode:h,path:t,oid:k,type:d}}}async function ds({fs:i,cache:e,dir:t,gitdir:r,ours:n,theirs:a,fastForward:s=!0,fastForwardOnly:o=!1,dryRun:c=!1,noUpdateBranch:u=!1,abortOnConflict:f=!0,message:d,author:h,committer:w,signingKey:_,onSign:y,mergeDriver:b}){n===void 0&&(n=await kt({fs:i,gitdir:r,fullname:!0})),n=await G.expand({fs:i,gitdir:r,ref:n}),a=await G.expand({fs:i,gitdir:r,ref:a});const v=await G.resolve({fs:i,gitdir:r,ref:n}),k=await G.resolve({fs:i,gitdir:r,ref:a}),S=await tn({fs:i,cache:e,gitdir:r,oids:[v,k]});if(S.length!==1)throw new Xt;const O=S[0];if(O===k)return{oid:v,alreadyMerged:!0};if(s&&O===v)return!c&&!u&&await G.writeRef({fs:i,gitdir:r,ref:n,value:k}),{oid:k,fastForward:!0};{if(o)throw new lr;const I=await Be.acquire({fs:i,gitdir:r,cache:e,allowUnmerged:!1},async x=>Wf({fs:i,cache:e,dir:t,gitdir:r,index:x,ourOid:v,theirOid:k,baseOid:O,ourName:Tt(n),baseName:"base",theirName:Tt(a),dryRun:c,abortOnConflict:f,mergeDriver:b}));if(I instanceof Kt)throw I;return d||(d=`Merge branch '${Tt(a)}' into ${Tt(n)}`),{oid:await Ur({fs:i,cache:e,gitdir:r,message:d,ref:n,tree:I,parent:[v,k],author:h,committer:w,signingKey:_,onSign:y,dryRun:c,noUpdateBranch:u}),tree:I,mergeCommit:!0}}}async function ws({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:u,ref:f,url:d,remote:h,remoteRef:w,prune:_,pruneTags:y,fastForward:b,fastForwardOnly:v,corsProxy:k,singleBranch:S,headers:O,author:I,committer:A,signingKey:x}){try{if(!f){const j=await kt({fs:i,gitdir:u});if(!j)throw new He("ref");f=j}const{fetchHead:R,fetchHeadDescription:D}=await Qi({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,gitdir:u,corsProxy:k,ref:f,url:d,remote:h,remoteRef:w,singleBranch:S,headers:O,prune:_,pruneTags:y});await ds({fs:i,cache:e,gitdir:u,ours:f,theirs:R,fastForward:b,fastForwardOnly:v,message:`Merge ${D}`,author:I,committer:A,signingKey:x,dryRun:!1,noUpdateBranch:!1}),await Vi({fs:i,cache:e,onProgress:r,dir:c,gitdir:u,ref:f,remote:h,noCheckout:!1})}catch(R){throw R.caller="git.pull",R}}async function ms({fs:i,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,dir:o,gitdir:c=M.join(o,".git"),ref:u,url:f,remote:d,remoteRef:h,corsProxy:w,singleBranch:_,headers:y={},cache:b={}}){try{T("fs",i),T("http",e),T("gitdir",c);const v={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await ws({fs:new Q(i),cache:b,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,dir:o,gitdir:c,ref:u,url:f,remote:d,remoteRef:h,fastForwardOnly:!0,corsProxy:w,singleBranch:_,headers:y,author:v,committer:v})}catch(v){throw v.caller="git.fastForward",v}}async function ps({fs:i,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,dir:o,gitdir:c=M.join(o,".git"),ref:u,remote:f,remoteRef:d,url:h,corsProxy:w,depth:_=null,since:y=null,exclude:b=[],relative:v=!1,tags:k=!1,singleBranch:S=!1,headers:O={},prune:I=!1,pruneTags:A=!1,cache:x={}}){try{return T("fs",i),T("http",e),T("gitdir",c),await Qi({fs:new Q(i),cache:x,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,gitdir:c,ref:u,remote:f,remoteRef:d,url:h,corsProxy:w,depth:_,since:y,exclude:b,relative:v,tags:k,singleBranch:S,headers:O,prune:I,pruneTags:A})}catch(R){throw R.caller="git.fetch",R}}async function _s({fs:i,dir:e,gitdir:t=M.join(e,".git"),oids:r,cache:n={}}){try{return T("fs",i),T("gitdir",t),T("oids",r),await tn({fs:new Q(i),cache:n,gitdir:t,oids:r})}catch(a){throw a.caller="git.findMergeBase",a}}async function gs({fs:i,filepath:e}){if(await i.exists(M.join(e,".git")))return e;{const t=zt(e);if(t===e)throw new be(`git root for ${e}`);return gs({fs:i,filepath:t})}}async function vs({fs:i,filepath:e}){try{return T("fs",i),T("filepath",e),await gs({fs:new Q(i),filepath:e})}catch(t){throw t.caller="git.findRoot",t}}async function bs({fs:i,dir:e,gitdir:t=M.join(e,".git"),path:r}){try{return T("fs",i),T("gitdir",t),T("path",r),await rr({fs:new Q(i),gitdir:t,path:r})}catch(n){throw n.caller="git.getConfig",n}}async function Kf({fs:i,gitdir:e,path:t}){return(await Oe.get({fs:i,gitdir:e})).getall(t)}async function ys({fs:i,dir:e,gitdir:t=M.join(e,".git"),path:r}){try{return T("fs",i),T("gitdir",t),T("path",r),await Kf({fs:new Q(i),gitdir:t,path:r})}catch(n){throw n.caller="git.getConfigAll",n}}async function ks({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,url:a,headers:s={},forPush:o=!1}){try{T("http",i),T("url",a);const u=await Lr.getRemoteHelperFor({url:a}).discover({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,service:o?"git-receive-pack":"git-upload-pack",url:a,headers:s,protocolVersion:1}),f={capabilities:[...u.capabilities]};for(const[d,h]of u.refs){const w=d.split("/"),_=w.pop();let y=f;for(const b of w)y[b]=y[b]||{},y=y[b];y[_]=h}for(const[d,h]of u.symrefs){const w=d.split("/"),_=w.pop();let y=f;for(const b of w)y[b]=y[b]||{},y=y[b];y[_]=h}return f}catch(c){throw c.caller="git.getRemoteInfo",c}}function xs(i,e,t,r){const n=[];for(const[a,s]of i.refs){if(e&&!a.startsWith(e))continue;if(a.endsWith("^{}")){if(r){const c=a.replace("^{}",""),u=n[n.length-1],f=u.ref===c?u:n.find(d=>d.ref===c);if(f===void 0)throw new Error("I did not expect this to happen");f.peeled=s}continue}const o={ref:a,oid:s};t&&i.symrefs.has(a)&&(o.target=i.symrefs.get(a)),n.push(o)}return n}async function Es({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,url:a,headers:s={},forPush:o=!1,protocolVersion:c=2}){try{T("http",i),T("url",a);const f=await Lr.getRemoteHelperFor({url:a}).discover({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,service:o?"git-receive-pack":"git-upload-pack",url:a,headers:s,protocolVersion:c});if(f.protocolVersion===2)return{protocolVersion:f.protocolVersion,capabilities:f.capabilities2};const d={};for(const h of f.capabilities){const[w,_]=h.split("=");_?d[w]=_:d[w]=!0}return{protocolVersion:1,capabilities:d,refs:xs(f,void 0,!0,!0)}}catch(u){throw u.caller="git.getRemoteInfo2",u}}async function Yf({type:i,object:e,format:t="content",oid:r=void 0}){return t!=="deflated"&&(t!=="wrapped"&&(e=Wt.wrap({type:i,object:e})),r=await lt(e)),{oid:r,object:e}}async function Ss({object:i}){try{T("object",i),typeof i=="string"?i=Buffer.from(i,"utf8"):i=Buffer.from(i);const e="blob",{oid:t,object:r}=await Yf({type:"blob",format:"content",object:i});return{oid:t,type:e,object:new Uint8Array(r),format:"wrapped"}}catch(e){throw e.caller="git.hashBlob",e}}async function Vf({fs:i,cache:e,onProgress:t,dir:r,gitdir:n,filepath:a}){try{a=M.join(r,a);const s=await i.read(a),o=u=>xe({fs:i,cache:e,gitdir:n,oid:u}),c=await Mt.fromPack({pack:s,getExternalRefDelta:o,onProgress:t});return await i.write(a.replace(/\.pack$/,".idx"),await c.toBuffer()),{oids:[...c.hashes]}}catch(s){throw s.caller="git.indexPack",s}}async function Rs({fs:i,onProgress:e,dir:t,gitdir:r=M.join(t,".git"),filepath:n,cache:a={}}){try{return T("fs",i),T("dir",t),T("gitdir",t),T("filepath",n),await Vf({fs:new Q(i),cache:a,onProgress:e,dir:t,gitdir:r,filepath:n})}catch(s){throw s.caller="git.indexPack",s}}async function rn({fs:i,bare:e=!1,dir:t,gitdir:r=e?t:M.join(t,".git"),defaultBranch:n="master"}){try{return T("fs",i),T("gitdir",r),e||T("dir",t),await ns({fs:new Q(i),bare:e,dir:t,gitdir:r,defaultBranch:n})}catch(a){throw a.caller="git.init",a}}async function Ts({fs:i,cache:e,gitdir:t,oid:r,ancestor:n,depth:a}){const s=await ir.read({fs:i,gitdir:t});if(!r)throw new He("oid");if(!n)throw new He("ancestor");if(r===n)return!1;const o=[r],c=new Set;let u=0;for(;o.length;){if(u++===a)throw new hr(a);const f=o.shift(),{type:d,object:h}=await xe({fs:i,cache:e,gitdir:t,oid:f});if(d!=="commit")throw new Ue(f,d,"commit");const w=ke.from(h).parse();for(const _ of w.parent)if(_===n)return!0;if(!s.has(f))for(const _ of w.parent)c.has(_)||(o.push(_),c.add(_))}return!1}async function $s({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,ancestor:n,depth:a=-1,cache:s={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),T("ancestor",n),await Ts({fs:new Q(i),cache:s,gitdir:t,oid:r,ancestor:n,depth:a})}catch(o){throw o.caller="git.isDescendent",o}}async function As({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r}){try{return T("fs",i),T("dir",e),T("gitdir",t),T("filepath",r),Jt.isIgnored({fs:new Q(i),dir:e,gitdir:t,filepath:r})}catch(n){throw n.caller="git.isIgnored",n}}async function Os({fs:i,dir:e,gitdir:t=M.join(e,".git"),remote:r}){try{return T("fs",i),T("gitdir",t),G.listBranches({fs:new Q(i),gitdir:t,remote:r})}catch(n){throw n.caller="git.listBranches",n}}async function Jf({fs:i,gitdir:e,ref:t,cache:r}){if(t){const n=await G.resolve({gitdir:e,fs:i,ref:t}),a=[];return await Is({fs:i,cache:r,gitdir:e,oid:n,filenames:a,prefix:""}),a}else return Be.acquire({fs:i,gitdir:e,cache:r},async function(n){return n.entries.map(a=>a.path)})}async function Is({fs:i,cache:e,gitdir:t,oid:r,filenames:n,prefix:a}){const{tree:s}=await Qt({fs:i,cache:e,gitdir:t,oid:r});for(const o of s)o.type==="tree"?await Is({fs:i,cache:e,gitdir:t,oid:o.oid,filenames:n,prefix:M.join(a,o.path)}):n.push(M.join(a,o.path))}async function js({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,cache:n={}}){try{return T("fs",i),T("gitdir",t),await Jf({fs:new Q(i),cache:n,gitdir:t,ref:r})}catch(a){throw a.caller="git.listFiles",a}}async function Qf({fs:i,cache:e,gitdir:t,ref:r}){let n;try{n=await G.resolve({gitdir:t,fs:i,ref:r})}catch(o){if(o instanceof be)return[]}return(await Qt({fs:i,cache:e,gitdir:t,oid:n})).tree.map(o=>({target:o.path,note:o.oid}))}async function Bs({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r="refs/notes/commits",cache:n={}}){try{return T("fs",i),T("gitdir",t),T("ref",r),await Qf({fs:new Q(i),cache:n,gitdir:t,ref:r})}catch(a){throw a.caller="git.listNotes",a}}async function Cs({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r}){try{return T("fs",i),T("gitdir",t),G.listRefs({fs:new Q(i),gitdir:t,filepath:r})}catch(n){throw n.caller="git.listRefs",n}}async function el({fs:i,gitdir:e}){const t=await Oe.get({fs:i,gitdir:e}),r=await t.getSubsections("remote");return Promise.all(r.map(async a=>{const s=await t.get(`remote.${a}.url`);return{remote:a,url:s}}))}async function Ds({fs:i,dir:e,gitdir:t=M.join(e,".git")}){try{return T("fs",i),T("gitdir",t),await el({fs:new Q(i),gitdir:t})}catch(r){throw r.caller="git.listRemotes",r}}async function tl(i){const e=Te.streamReader(i),t=[];let r;for(;r=await e(),r!==!0;){if(r===null)continue;r=r.toString("utf8").replace(/\n$/,"");const[n,a,...s]=r.split(" "),o={ref:a,oid:n};for(const c of s){const[u,f]=c.split(":");u==="symref-target"?o.target=f:u==="peeled"&&(o.peeled=f)}t.push(o)}return t}async function rl({prefix:i,symrefs:e,peelTags:t}){const r=[];return r.push(Te.encode(`command=ls-refs
`)),r.push(Te.encode(`agent=${Hr.agent}
`)),(t||e||i)&&r.push(Te.delim()),t&&r.push(Te.encode("peel")),e&&r.push(Te.encode("symrefs")),i&&r.push(Te.encode(`ref-prefix ${i}`)),r.push(Te.flush()),r}async function Ps({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,url:a,headers:s={},forPush:o=!1,protocolVersion:c=2,prefix:u,symrefs:f,peelTags:d}){try{T("http",i),T("url",a);const h=await Nr.discover({http:i,onAuth:e,onAuthSuccess:t,onAuthFailure:r,corsProxy:n,service:o?"git-receive-pack":"git-upload-pack",url:a,headers:s,protocolVersion:c});if(h.protocolVersion===1)return xs(h,u,f,d);const w=await rl({prefix:u,symrefs:f,peelTags:d}),_=await Nr.connect({http:i,auth:h.auth,headers:s,corsProxy:n,service:o?"git-receive-pack":"git-upload-pack",url:a,body:w});return tl(_.body)}catch(h){throw h.caller="git.listServerRefs",h}}async function Ns({fs:i,dir:e,gitdir:t=M.join(e,".git")}){try{return T("fs",i),T("gitdir",t),G.listTags({fs:new Q(i),gitdir:t})}catch(r){throw r.caller="git.listTags",r}}function il(i,e){return i.committer.timestamp-e.committer.timestamp}const nl="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function pa({fs:i,cache:e,gitdir:t,oid:r,fileId:n}){if(n===nl)return;const a=r;let s;const o=await Lt({fs:i,cache:e,gitdir:t,oid:r}),c=o.tree;return n===o.oid?s=o.path:(s=await zs({fs:i,cache:e,gitdir:t,tree:c,fileId:n,oid:a}),Array.isArray(s)&&(s.length===0?s=void 0:s.length===1&&(s=s[0]))),s}async function zs({fs:i,cache:e,gitdir:t,tree:r,fileId:n,oid:a,filepaths:s=[],parentPath:o=""}){const c=r.entries().map(function(u){let f;return u.oid===n?(f=M.join(o,u.path),s.push(f)):u.type==="tree"&&(f=xe({fs:i,cache:e,gitdir:t,oid:u.oid}).then(function({object:d}){return zs({fs:i,cache:e,gitdir:t,tree:qe.from(d),fileId:n,oid:a,filepaths:s,parentPath:M.join(o,u.path)})})),f});return await Promise.all(c),s}async function al({fs:i,cache:e,gitdir:t,filepath:r,ref:n,depth:a,since:s,force:o,follow:c}){const u=typeof s>"u"?void 0:Math.floor(s.valueOf()/1e3),f=[],d=await ir.read({fs:i,gitdir:t}),h=await G.resolve({fs:i,gitdir:t,ref:n}),w=[await qt({fs:i,cache:e,gitdir:t,oid:h})];let _,y,b;function v(k){b&&r&&f.push(k)}for(;w.length>0;){const k=w.pop();if(u!==void 0&&k.commit.committer.timestamp<=u)break;if(r){let S;try{S=await vr({fs:i,cache:e,gitdir:t,oid:k.commit.tree,filepath:r}),y&&_!==S&&f.push(y),_=S,y=k,b=!0}catch(O){if(O instanceof be){let I=c&&_;if(I&&(I=await pa({fs:i,cache:e,gitdir:t,oid:k.commit.tree,fileId:_}),I))if(Array.isArray(I)){if(y){const A=await pa({fs:i,cache:e,gitdir:t,oid:y.commit.tree,fileId:_});if(Array.isArray(A))if(I=I.filter(x=>A.indexOf(x)===-1),I.length===1)I=I[0],r=I,y&&f.push(y);else{I=!1,y&&f.push(y);break}}}else r=I,y&&f.push(y);if(!I){if(b&&_&&(f.push(y),!o))break;if(!o&&!c)throw O}y=k,b=!1}else throw O}}else f.push(k);if(a!==void 0&&f.length===a){v(k);break}if(!d.has(k.oid))for(const S of k.commit.parent){const O=await qt({fs:i,cache:e,gitdir:t,oid:S});w.map(I=>I.oid).includes(O.oid)||w.push(O)}w.length===0&&v(k),w.sort((S,O)=>il(S.commit,O.commit))}return f}async function Ms({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r,ref:n="HEAD",depth:a,since:s,force:o,follow:c,cache:u={}}){try{return T("fs",i),T("gitdir",t),T("ref",n),await al({fs:new Q(i),cache:u,gitdir:t,filepath:r,ref:n,depth:a,since:s,force:o,follow:c})}catch(f){throw f.caller="git.log",f}}async function Fs({fs:i,onSign:e,dir:t,gitdir:r=M.join(t,".git"),ours:n,theirs:a,fastForward:s=!0,fastForwardOnly:o=!1,dryRun:c=!1,noUpdateBranch:u=!1,abortOnConflict:f=!0,message:d,author:h,committer:w,signingKey:_,cache:y={},mergeDriver:b}){try{T("fs",i),_&&T("onSign",e);const v=new Q(i),k=await bt({fs:v,gitdir:r,author:h});if(!k&&(!o||!s))throw new ze("author");const S=await Ht({fs:v,gitdir:r,author:k,committer:w});if(!S&&(!o||!s))throw new ze("committer");return await ds({fs:v,cache:y,dir:t,gitdir:r,ours:n,theirs:a,fastForward:s,fastForwardOnly:o,dryRun:c,noUpdateBranch:u,abortOnConflict:f,message:d,author:k,committer:S,signingKey:_,onSign:e,mergeDriver:b})}catch(v){throw v.caller="git.merge",v}}const sl={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function Us({fs:i,cache:e,dir:t,gitdir:r=M.join(t,".git"),oids:n}){const a=new xa,s=[];function o(f,d){const h=Buffer.from(f,d);s.push(h),a.update(h)}async function c({stype:f,object:d}){const h=sl[f];let w=d.length,_=w>15?128:0;const y=w&15;w=w>>>4;let b=(_|h|y).toString(16);for(o(b,"hex");_;)_=w>127?128:0,b=_|w&127,o(Hi(2,b),"hex"),w=w>>>7;o(Buffer.from(await Ua(d)))}o("PACK"),o("00000002","hex"),o(Hi(8,n.length),"hex");for(const f of n){const{type:d,object:h}=await xe({fs:i,cache:e,gitdir:r,oid:f});await c({object:h,stype:d})}const u=a.digest();return s.push(u),s}async function ol({fs:i,cache:e,gitdir:t,oids:r,write:n}){const a=await Us({fs:i,cache:e,gitdir:t,oids:r}),s=Buffer.from(await Pr(a)),c=`pack-${s.slice(-20).toString("hex")}.pack`;return n?(await i.write(M.join(t,`objects/pack/${c}`),s),{filename:c}):{filename:c,packfile:new Uint8Array(s)}}async function Ls({fs:i,dir:e,gitdir:t=M.join(e,".git"),oids:r,write:n=!1,cache:a={}}){try{return T("fs",i),T("gitdir",t),T("oids",r),await ol({fs:new Q(i),cache:a,gitdir:t,oids:r,write:n})}catch(s){throw s.caller="git.packObjects",s}}async function Hs({fs:i,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,dir:o,gitdir:c=M.join(o,".git"),ref:u,url:f,remote:d,remoteRef:h,prune:w=!1,pruneTags:_=!1,fastForward:y=!0,fastForwardOnly:b=!1,corsProxy:v,singleBranch:k,headers:S={},author:O,committer:I,signingKey:A,cache:x={}}){try{T("fs",i),T("gitdir",c);const R=new Q(i),D=await bt({fs:R,gitdir:c,author:O});if(!D)throw new ze("author");const j=await Ht({fs:R,gitdir:c,author:D,committer:I});if(!j)throw new ze("committer");return await ws({fs:R,cache:x,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,dir:o,gitdir:c,ref:u,url:f,remote:d,remoteRef:h,fastForward:y,fastForwardOnly:b,corsProxy:v,singleBranch:k,headers:S,author:D,committer:j,signingKey:A,prune:w,pruneTags:_})}catch(R){throw R.caller="git.pull",R}}async function cl({fs:i,cache:e,dir:t,gitdir:r=M.join(t,".git"),start:n,finish:a}){const s=await ir.read({fs:i,gitdir:r}),o=new Set,c=new Set;for(const d of n)o.add(await G.resolve({fs:i,gitdir:r,ref:d}));for(const d of a)try{const h=await G.resolve({fs:i,gitdir:r,ref:d});c.add(h)}catch{}const u=new Set;async function f(d){u.add(d);const{type:h,object:w}=await xe({fs:i,cache:e,gitdir:r,oid:d});if(h==="tag"){const y=Fe.from(w).headers().object;return f(y)}if(h!=="commit")throw new Ue(d,h,"commit");if(!s.has(d)){const y=ke.from(w).headers().parent;for(d of y)!c.has(d)&&!u.has(d)&&await f(d)}}for(const d of o)await f(d);return u}async function Ni({fs:i,cache:e,dir:t,gitdir:r=M.join(t,".git"),oids:n}){const a=new Set;async function s(o){if(a.has(o))return;a.add(o);const{type:c,object:u}=await xe({fs:i,cache:e,gitdir:r,oid:o});if(c==="tag"){const d=Fe.from(u).headers().object;await s(d)}else if(c==="commit"){const d=ke.from(u).headers().tree;await s(d)}else if(c==="tree"){const f=qe.from(u);for(const d of f)d.type==="blob"&&a.add(d.oid),d.type==="tree"&&await s(d.oid)}}for(const o of n)await s(o);return a}async function fl(i){const e={};let t="";const r=Te.streamReader(i);let n=await r();for(;n!==!0;)n!==null&&(t+=n.toString("utf8")+`
`),n=await r();const a=t.toString("utf8").split(`
`);if(n=a.shift(),!n.startsWith("unpack "))throw new Ot('unpack ok" or "unpack [error message]',n);e.ok=n==="unpack ok",e.ok||(e.error=n.slice(7)),e.refs={};for(const s of a){if(s.trim()==="")continue;const o=s.slice(0,2),c=s.slice(3);let u=c.indexOf(" ");u===-1&&(u=c.length);const f=c.slice(0,u),d=c.slice(u+1);e.refs[f]={ok:o==="ok",error:d}}return e}async function ll({capabilities:i=[],triplets:e=[]}){const t=[];let r=`\0 ${i.join(" ")}`;for(const n of e)t.push(Te.encode(`${n.oldoid} ${n.oid} ${n.fullRef}${r}
`)),r="";return t.push(Te.flush()),t}async function ul({fs:i,cache:e,http:t,onProgress:r,onMessage:n,onAuth:a,onAuthSuccess:s,onAuthFailure:o,onPrePush:c,gitdir:u,ref:f,remoteRef:d,remote:h,url:w,force:_=!1,delete:y=!1,corsProxy:b,headers:v={}}){const k=f||await kt({fs:i,gitdir:u});if(typeof k>"u")throw new He("ref");const S=await Oe.get({fs:i,gitdir:u});h=h||await S.get(`branch.${k}.pushRemote`)||await S.get("remote.pushDefault")||await S.get(`branch.${k}.remote`)||"origin";const O=w||await S.get(`remote.${h}.pushurl`)||await S.get(`remote.${h}.url`);if(typeof O>"u")throw new He("remote OR url");const I=d||await S.get(`branch.${k}.merge`);if(typeof O>"u")throw new He("remoteRef");b===void 0&&(b=await S.get("http.corsProxy"));const A=await G.expand({fs:i,gitdir:u,ref:k}),x=y?"0000000000000000000000000000000000000000":await G.resolve({fs:i,gitdir:u,ref:A}),R=Lr.getRemoteHelperFor({url:O}),D=await R.discover({http:t,onAuth:a,onAuthSuccess:s,onAuthFailure:o,corsProxy:b,service:"git-receive-pack",url:O,headers:v,protocolVersion:1}),j=D.auth;let H;if(!I)H=A;else try{H=await G.expandAgainstMap({ref:I,map:D.refs})}catch(re){if(re instanceof be)H=I.startsWith("refs/")?I:`refs/heads/${I}`;else throw re}const L=D.refs.get(H)||"0000000000000000000000000000000000000000";if(c&&!await c({remote:h,url:O,localRef:{ref:y?"(delete)":A,oid:x},remoteRef:{ref:H,oid:L}}))throw new Yt;const F=!D.capabilities.has("no-thin");let K=new Set;if(!y){const re=[...D.refs.values()];let le=new Set;if(L!=="0000000000000000000000000000000000000000"){const we=await tn({fs:i,cache:e,gitdir:u,oids:[x,L]});for(const ye of we)re.push(ye);F&&(le=await Ni({fs:i,cache:e,gitdir:u,oids:we}))}if(!re.includes(x)){const we=await cl({fs:i,cache:e,gitdir:u,start:[x],finish:re});K=await Ni({fs:i,cache:e,gitdir:u,oids:we})}if(F){try{const we=await G.resolve({fs:i,gitdir:u,ref:`refs/remotes/${h}/HEAD`,depth:2}),{oid:ye}=await G.resolveAgainstMap({ref:we.replace(`refs/remotes/${h}/`,""),fullref:we,map:D.refs}),ue=[ye];for(const oe of await Ni({fs:i,cache:e,gitdir:u,oids:ue}))le.add(oe)}catch{}for(const we of le)K.delete(we)}if(x===L&&(_=!0),!_){if(A.startsWith("refs/tags")&&L!=="0000000000000000000000000000000000000000")throw new Ut("tag-exists");if(x!=="0000000000000000000000000000000000000000"&&L!=="0000000000000000000000000000000000000000"&&!await Ts({fs:i,cache:e,gitdir:u,oid:x,ancestor:L,depth:-1}))throw new Ut("not-fast-forward")}}const ce=ts([...D.capabilities],["report-status","side-band-64k",`agent=${Hr.agent}`]),ge=await ll({capabilities:ce,triplets:[{oldoid:L,oid:x,fullRef:H}]}),N=y?[]:await Us({fs:i,cache:e,gitdir:u,oids:[...K]}),U=await R.connect({http:t,onProgress:r,corsProxy:b,service:"git-receive-pack",url:O,auth:j,headers:v,body:[...ge,...N]}),{packfile:X,progress:ae}=await is.demux(U.body);if(n){const re=rs(ae);yr(re,async le=>{await n(le)})}const ie=await fl(X);if(U.headers&&(ie.headers=U.headers),h&&ie.ok&&ie.refs[H].ok&&!A.startsWith("refs/tags")){const re=`refs/remotes/${h}/${H.replace("refs/heads","")}`;y?await G.deleteRef({fs:i,gitdir:u,ref:re}):await G.writeRef({fs:i,gitdir:u,ref:re,value:x})}if(ie.ok&&Object.values(ie.refs).every(re=>re.ok))return ie;{const re=Object.entries(ie.refs).filter(([le,we])=>!we.ok).map(([le,we])=>`
  - ${le}: ${we.error}`).join("");throw new ur(re,ie)}}async function qs({fs:i,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,onPrePush:o,dir:c,gitdir:u=M.join(c,".git"),ref:f,remoteRef:d,remote:h="origin",url:w,force:_=!1,delete:y=!1,corsProxy:b,headers:v={},cache:k={}}){try{return T("fs",i),T("http",e),T("gitdir",u),await ul({fs:new Q(i),cache:k,http:e,onProgress:t,onMessage:r,onAuth:n,onAuthSuccess:a,onAuthFailure:s,onPrePush:o,gitdir:u,ref:f,remoteRef:d,remote:h,url:w,force:_,delete:y,corsProxy:b,headers:v})}catch(S){throw S.caller="git.push",S}}async function Zs({fs:i,cache:e,gitdir:t,oid:r}){const{type:n,object:a}=await xe({fs:i,cache:e,gitdir:t,oid:r});if(n==="tag")return r=Fe.from(a).parse().object,Zs({fs:i,cache:e,gitdir:t,oid:r});if(n!=="blob")throw new Ue(r,n,"blob");return{oid:r,blob:new Uint8Array(a)}}async function Gs({fs:i,cache:e,gitdir:t,oid:r,filepath:n=void 0}){return n!==void 0&&(r=await vr({fs:i,cache:e,gitdir:t,oid:r,filepath:n})),await Zs({fs:i,cache:e,gitdir:t,oid:r})}async function Ws({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,filepath:n,cache:a={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),await Gs({fs:new Q(i),cache:a,gitdir:t,oid:r,filepath:n})}catch(s){throw s.caller="git.readBlob",s}}async function nn({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,cache:n={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),await qt({fs:new Q(i),cache:n,gitdir:t,oid:r})}catch(a){throw a.caller="git.readCommit",a}}async function hl({fs:i,cache:e,gitdir:t,ref:r="refs/notes/commits",oid:n}){const a=await G.resolve({gitdir:t,fs:i,ref:r}),{blob:s}=await Gs({fs:i,cache:e,gitdir:t,oid:a,filepath:n});return s}async function Xs({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r="refs/notes/commits",oid:n,cache:a={}}){try{return T("fs",i),T("gitdir",t),T("ref",r),T("oid",n),await hl({fs:new Q(i),cache:a,gitdir:t,ref:r,oid:n})}catch(s){throw s.caller="git.readNote",s}}async function Ks({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,format:n="parsed",filepath:a=void 0,encoding:s=void 0,cache:o={}}){try{T("fs",i),T("gitdir",t),T("oid",r);const c=new Q(i);a!==void 0&&(r=await vr({fs:c,cache:o,gitdir:t,oid:r,filepath:a}));const f=await xe({fs:c,cache:o,gitdir:t,oid:r,format:n==="parsed"?"content":n});if(f.oid=r,n==="parsed")switch(f.format="parsed",f.type){case"commit":f.object=ke.from(f.object).parse();break;case"tree":f.object=qe.from(f.object).entries();break;case"blob":s?f.object=f.object.toString(s):(f.object=new Uint8Array(f.object),f.format="content");break;case"tag":f.object=Fe.from(f.object).parse();break;default:throw new Ue(f.oid,f.type,"blob|commit|tag|tree")}else(f.format==="deflated"||f.format==="wrapped")&&(f.type=f.format);return f}catch(c){throw c.caller="git.readObject",c}}async function dl({fs:i,cache:e,gitdir:t,oid:r}){const{type:n,object:a}=await xe({fs:i,cache:e,gitdir:t,oid:r,format:"content"});if(n!=="tag")throw new Ue(r,n,"tag");const s=Fe.from(a);return{oid:r,tag:s.parse(),payload:s.payload()}}async function Ys({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,cache:n={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),await dl({fs:new Q(i),cache:n,gitdir:t,oid:r})}catch(a){throw a.caller="git.readTag",a}}async function Vs({fs:i,dir:e,gitdir:t=M.join(e,".git"),oid:r,filepath:n=void 0,cache:a={}}){try{return T("fs",i),T("gitdir",t),T("oid",r),await Qt({fs:new Q(i),cache:a,gitdir:t,oid:r,filepath:n})}catch(s){throw s.caller="git.readTree",s}}async function Js({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r,cache:n={}}){try{T("fs",i),T("gitdir",t),T("filepath",r),await Be.acquire({fs:new Q(i),gitdir:t,cache:n},async function(a){a.delete({filepath:r})})}catch(a){throw a.caller="git.remove",a}}async function wl({fs:i,cache:e,onSign:t,gitdir:r,ref:n="refs/notes/commits",oid:a,author:s,committer:o,signingKey:c}){let u;try{u=await G.resolve({gitdir:r,fs:i,ref:n})}catch(_){if(!(_ instanceof be))throw _}let d=(await Qt({fs:i,gitdir:r,oid:u||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;d=d.filter(_=>_.path!==a);const h=await br({fs:i,gitdir:r,tree:d});return await Ur({fs:i,cache:e,onSign:t,gitdir:r,ref:n,tree:h,parent:u&&[u],message:`Note removed by 'isomorphic-git removeNote'
`,author:s,committer:o,signingKey:c})}async function Qs({fs:i,onSign:e,dir:t,gitdir:r=M.join(t,".git"),ref:n="refs/notes/commits",oid:a,author:s,committer:o,signingKey:c,cache:u={}}){try{T("fs",i),T("gitdir",r),T("oid",a);const f=new Q(i),d=await bt({fs:f,gitdir:r,author:s});if(!d)throw new ze("author");const h=await Ht({fs:f,gitdir:r,author:d,committer:o});if(!h)throw new ze("committer");return await wl({fs:f,cache:u,onSign:e,gitdir:r,ref:n,oid:a,author:d,committer:h,signingKey:c})}catch(f){throw f.caller="git.removeNote",f}}async function ml({fs:i,gitdir:e,oldref:t,ref:r,checkout:n=!1}){if(r!==at.clean(r))throw new Qe(r,at.clean(r));if(t!==at.clean(t))throw new Qe(t,at.clean(t));const a=`refs/heads/${t}`,s=`refs/heads/${r}`;if(await G.exists({fs:i,gitdir:e,ref:s}))throw new et("branch",r,!1);const c=await G.resolve({fs:i,gitdir:e,ref:a,depth:1});await G.writeRef({fs:i,gitdir:e,ref:s,value:c}),await G.deleteRef({fs:i,gitdir:e,ref:a});const f=await kt({fs:i,gitdir:e,fullname:!0})===a;(n||f)&&await G.writeSymbolicRef({fs:i,gitdir:e,ref:"HEAD",value:s})}async function eo({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,oldref:n,checkout:a=!1}){try{return T("fs",i),T("gitdir",t),T("ref",r),T("oldref",n),await ml({fs:new Q(i),gitdir:t,ref:r,oldref:n,checkout:a})}catch(s){throw s.caller="git.renameBranch",s}}async function to({gitdir:i,type:e,object:t}){return lt(Wt.wrap({type:e,object:t}))}async function ro({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r,ref:n,cache:a={}}){try{T("fs",i),T("gitdir",t),T("filepath",r);const s=new Q(i);let o,c;try{o=await G.resolve({fs:s,gitdir:t,ref:n||"HEAD"})}catch(d){if(n)throw d}if(o)try{o=await vr({fs:s,cache:a,gitdir:t,oid:o,filepath:r})}catch{o=null}let u={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const f=e&&await s.read(M.join(e,r));f&&(c=await to({gitdir:t,type:"blob",object:f}),o===c&&(u=await s.lstat(M.join(e,r)))),await Be.acquire({fs:s,gitdir:t,cache:a},async function(d){d.delete({filepath:r}),o&&d.insert({filepath:r,stats:u,oid:o})})}catch(s){throw s.caller="git.reset",s}}async function io({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,depth:n}){try{return T("fs",i),T("gitdir",t),T("ref",r),await G.resolve({fs:new Q(i),gitdir:t,ref:r,depth:n})}catch(a){throw a.caller="git.resolveRef",a}}async function no({fs:i,dir:e,gitdir:t=M.join(e,".git"),path:r,value:n,append:a=!1}){try{T("fs",i),T("gitdir",t),T("path",r);const s=new Q(i),o=await Oe.get({fs:s,gitdir:t});a?await o.append(r,n):await o.set(r,n),await Oe.save({fs:s,gitdir:t,config:o})}catch(s){throw s.caller="git.setConfig",s}}async function ao({fs:i,gitdir:e,commit:t}){const r=ke.from(t).toObject();return await Ze({fs:i,gitdir:e,type:"commit",object:r,format:"content"})}class zr{static get timezoneOffsetForRefLogEntry(){const e=new Date().getTimezoneOffset(),t=Math.abs(Math.floor(e/60)),r=Math.abs(e%60).toString().padStart(2,"0");return`${e>0?"-":"+"}${t.toString().padStart(2,"0")}${r}`}static createStashReflogEntry(e,t,r){const n=e.name.replace(/\s/g,""),a="0000000000000000000000000000000000000000",s=Math.floor(Date.now()/1e3),o=zr.timezoneOffsetForRefLogEntry;return`${a} ${t} ${n} ${e.email} ${s} ${o}	${r}
`}static getStashReflogEntry(e,t=!1){return e.split(`
`).filter(a=>a).reverse().map((a,s)=>t?`stash@{${s}}: ${a.split("	")[1]}`:a)}}const pl={stage:At,workdir:Vt};let zi;async function Zt(i,e){return zi===void 0&&(zi=new tr),zi.acquire(i,e)}async function _l(i,e,t,r,n=null){const a=M.join(t,r),s=await i.lstat(a);if(!s)throw new be(a);if(s.isDirectory())throw new se(`${a}: file expected, but found directory`);const o=n?await Ca({fs:i,gitdir:e,oid:n}):void 0;let c=o?n:void 0;return o||await Zt({fs:i,gitdir:e,currentFilepath:a},async()=>{const u=s.isSymbolicLink()?await i.readlink(a).then(La):await i.read(a);if(u===null)throw new be(a);c=await Ze({fs:i,gitdir:e,type:"blob",object:u})}),c}async function gl({fs:i,dir:e,gitdir:t,entries:r}){async function n(a){if(a.type==="tree"){if(!a.oid){const s=await Promise.all(a.children.map(n));a.oid=await br({fs:i,gitdir:t,tree:s}),a.mode=16384}}else a.type==="blob"&&(a.oid=await _l(i,t,e,a.path,a.oid),a.mode=33188);return a.path=a.path.split("/").pop(),a}return Promise.all(r.map(n))}async function _a({fs:i,dir:e,gitdir:t,treePair:r}){const n=r[1]==="stage",a=r.map(w=>typeof w=="string"?pl[w]():w),s=[],f=await vt({fs:i,cache:{},dir:e,gitdir:t,trees:a,map:async(w,[_,y])=>{if(!(w==="."||await Jt.isIgnored({fs:i,dir:e,gitdir:t,filepath:w}))&&y)return(!_||await _.oid()!==await y.oid()&&await y.oid()!==void 0)&&s.push([_,y]),{mode:await y.mode(),path:w,oid:await y.oid(),type:await y.type()}},reduce:async(w,_)=>(_=_.filter(Boolean),w?(w.children=_,w):_.length>0?_:void 0),iterate:async(w,_)=>{const y=[];for(const b of _){const[v,k]=b;n?k&&(await i.exists(`${e}/${k.toString()}`)?y.push(b):s.push([null,k])):v&&(k?y.push(b):s.push([v,null]))}return y.length?Promise.all(y.map(w)):[]}});if(s.length===0||f.length===0)return null;const h=(await gl({fs:i,dir:e,gitdir:t,entries:f})).filter(Boolean).map(w=>({mode:w.mode,path:w.path,oid:w.oid,type:w.type}));return br({fs:i,gitdir:t,tree:h})}async function vl({fs:i,dir:e,gitdir:t,stashCommit:r,parentCommit:n,wasStaged:a}){const s=[],o=[],c=await vt({fs:i,cache:{},dir:e,gitdir:t,trees:[Ge({ref:n}),Ge({ref:r})],map:async(u,[f,d])=>{if(u==="."||await Jt.isIgnored({fs:i,dir:e,gitdir:t,filepath:u}))return;const h=d?await d.type():await f.type();if(h!=="tree"&&h!=="blob")return;if(!d&&f){const _=h==="tree"?"rmdir":"rm";return h==="tree"&&s.push(u),h==="blob"&&a&&o.push({filepath:u,oid:await f.oid()}),{method:_,filepath:u}}const w=await d.oid();if(!f||await f.oid()!==w)return h==="tree"?{method:"mkdir",filepath:u}:(a&&o.push({filepath:u,oid:w,stats:await i.lstat(M.join(e,u))}),{method:"write",filepath:u,oid:w})}});await Zt({fs:i,gitdir:t,dirRemoved:s,ops:c},async()=>{for(const u of c){const f=M.join(e,u.filepath);switch(u.method){case"rmdir":await i.rmdir(f);break;case"mkdir":await i.mkdir(f);break;case"rm":await i.rm(f);break;case"write":if(!s.some(d=>f.startsWith(d))){const{object:d}=await xe({fs:i,cache:{},gitdir:t,oid:u.oid});await i.exists(f)&&await i.rm(f),await i.write(f,d)}break}}}),await Be.acquire({fs:i,gitdir:t,cache:{}},async u=>{o.forEach(({filepath:f,stats:d,oid:h})=>{u.insert({filepath:f,stats:d,oid:h})})})}class ft{constructor({fs:e,dir:t,gitdir:r=M.join(t,".git")}){Object.assign(this,{fs:e,dir:t,gitdir:r,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return M.join(this.gitdir,ft.refStash)}get refLogsStashPath(){return M.join(this.gitdir,ft.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await bt({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new ze("author");return this._author}async getStashSHA(e,t){return await this.fs.exists(this.refStashPath)?(t||await this.readStashReflogs({parsed:!1}))[e].split(" ")[1]:null}async writeStashCommit({message:e,tree:t,parent:r}){return ao({fs:this.fs,gitdir:this.gitdir,commit:{message:e,tree:t,parent:r,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(e){const t=await this.readStashReflogs({parsed:!1});if(e!==0&&(e<0||e>t.length-1))throw new Qe(`stash@${e}`,"number that is in range of [0, num of stash pushed]");const r=await this.getStashSHA(e,t);return r?qt({fs:this.fs,cache:{},gitdir:this.gitdir,oid:r}):{}}async writeStashRef(e){return G.writeRef({fs:this.fs,gitdir:this.gitdir,ref:ft.refStash,value:e})}async writeStashReflogEntry({stashCommit:e,message:t}){const r=await this.getAuthor(),n=zr.createStashReflogEntry(r,e,t),a=this.refLogsStashPath;await Zt({filepath:a,entry:n},async()=>{const s=await this.fs.exists(a)?await this.fs.read(a,"utf8"):"";await this.fs.write(a,s+n,"utf8")})}async readStashReflogs({parsed:e=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const r=(await this.fs.read(this.refLogsStashPath)).toString();return zr.getStashReflogEntry(r,e)}}async function bl({fs:i,dir:e,gitdir:t,message:r=""}){const n=new ft({fs:i,dir:e,gitdir:t});await n.getAuthor();const a=await kt({fs:i,gitdir:t,fullname:!1}),s=await G.resolve({fs:i,gitdir:t,ref:"HEAD"}),c=(await nn({fs:i,dir:e,gitdir:t,oid:s})).commit.message,u=[s];let f=null,d=Ge({ref:"HEAD"});const h=await _a({fs:i,dir:e,gitdir:t,treePair:[Ge({ref:"HEAD"}),"stage"]});if(h){const b=await n.writeStashCommit({message:`stash-Index: WIP on ${a} - ${new Date().toISOString()}`,tree:h,parent:u});u.push(b),f=h,d=At()}const w=await _a({fs:i,dir:e,gitdir:t,treePair:[d,"workdir"]});if(w){const b=await n.writeStashCommit({message:`stash-WorkDir: WIP on ${a} - ${new Date().toISOString()}`,tree:w,parent:[u[u.length-1]]});u.push(b),f=w}if(!f||!h&&!w)throw new be("changes, nothing to stash");const _=(r.trim()||`WIP on ${a}`)+`: ${s.substring(0,7)} ${c}`,y=await n.writeStashCommit({message:_,tree:f,parent:u});return await n.writeStashRef(y),await n.writeStashReflogEntry({stashCommit:y,message:_}),await Ji({fs:i,dir:e,gitdir:t,ref:a,track:!1,force:!0}),y}async function so({fs:i,dir:e,gitdir:t,refIdx:r=0}){const a=await new ft({fs:i,dir:e,gitdir:t}).readStashCommit(r),{parent:s=null}=a.commit?a.commit:{};if(!(!s||!Array.isArray(s)))for(let o=0;o<s.length-1;o++){const u=(await qt({fs:i,cache:{},gitdir:t,oid:s[o+1]})).commit.message.startsWith("stash-Index");await vl({fs:i,dir:e,gitdir:t,stashCommit:s[o+1],parentCommit:s[o],wasStaged:u})}}async function oo({fs:i,dir:e,gitdir:t,refIdx:r=0}){const n=new ft({fs:i,dir:e,gitdir:t});if(!(await n.readStashCommit(r)).commit)return;const s=n.refStashPath;await Zt(s,async()=>{await i.exists(s)&&await i.rm(s)});const o=await n.readStashReflogs({parsed:!1});if(!o.length)return;o.splice(r,1);const c=n.refLogsStashPath;await Zt({reflogEntries:o,stashReflogPath:c,stashMgr:n},async()=>{if(o.length){await i.write(c,o.join(`
`),"utf8");const u=o[o.length-1].split(" ")[1];await n.writeStashRef(u)}else await i.rm(c)})}async function yl({fs:i,dir:e,gitdir:t}){return new ft({fs:i,dir:e,gitdir:t}).readStashReflogs({parsed:!0})}async function kl({fs:i,dir:e,gitdir:t}){const r=new ft({fs:i,dir:e,gitdir:t}),n=[r.refStashPath,r.refLogsStashPath];await Zt(n,async()=>{await Promise.all(n.map(async a=>{if(await i.exists(a))return i.rm(a)}))})}async function xl({fs:i,dir:e,gitdir:t,refIdx:r=0}){await so({fs:i,dir:e,gitdir:t,refIdx:r}),await oo({fs:i,dir:e,gitdir:t,refIdx:r})}async function co({fs:i,dir:e,gitdir:t=M.join(e,".git"),op:r="push",message:n="",refIdx:a=0}){T("fs",i),T("dir",e),T("gitdir",t),T("op",r);const s={push:bl,apply:so,drop:oo,list:yl,clear:kl,pop:xl},o=["apply","drop","pop"];try{const c=new Q(i);["refs","logs","logs/refs"].map(d=>M.join(t,d)).forEach(async d=>{await c.exists(d)||await c.mkdir(d)});const f=s[r];if(f){if(o.includes(r)&&a<0)throw new Qe(`stash@${a}`,"number that is in range of [0, num of stash pushed]");return await f({fs:c,dir:e,gitdir:t,message:n,refIdx:a})}throw new Error(`To be implemented: ${r}`)}catch(c){throw c.caller="git.stash",c}}async function fo({fs:i,dir:e,gitdir:t=M.join(e,".git"),filepath:r,cache:n={}}){try{T("fs",i),T("gitdir",t),T("filepath",r);const a=new Q(i);if(await Jt.isIgnored({fs:a,gitdir:t,dir:e,filepath:r}))return"ignored";const o=await El({fs:a,cache:n,gitdir:t}),c=await lo({fs:a,cache:n,gitdir:t,tree:o,path:r}),u=await Be.acquire({fs:a,gitdir:t,cache:n},async function(y){for(const b of y)if(b.path===r)return b;return null}),f=await a.lstat(M.join(e,r)),d=c!==null,h=u!==null,w=f!==null,_=async()=>{if(h&&!Or(u,f))return u.oid;{const y=await a.read(M.join(e,r)),b=await to({gitdir:t,type:"blob",object:y});return h&&u.oid===b&&f.size!==-1&&Be.acquire({fs:a,gitdir:t,cache:n},async function(v){v.insert({filepath:r,stats:f,oid:b})}),b}};if(!d&&!w&&!h)return"absent";if(!d&&!w&&h)return"*absent";if(!d&&w&&!h)return"*added";if(!d&&w&&h)return await _()===u.oid?"added":"*added";if(d&&!w&&!h)return"deleted";if(d&&!w&&h)return c===u.oid,"*deleted";if(d&&w&&!h)return await _()===c?"*undeleted":"*undeletemodified";if(d&&w&&h){const y=await _();return y===c?y===u.oid?"unmodified":"*unmodified":y===u.oid?"modified":"*modified"}}catch(a){throw a.caller="git.status",a}}async function lo({fs:i,cache:e,gitdir:t,tree:r,path:n}){typeof n=="string"&&(n=n.split("/"));const a=n.shift();for(const s of r)if(s.path===a){if(n.length===0)return s.oid;const{type:o,object:c}=await xe({fs:i,cache:e,gitdir:t,oid:s.oid});if(o==="tree"){const u=qe.from(c);return lo({fs:i,cache:e,gitdir:t,tree:u,path:n})}if(o==="blob")throw new Ue(s.oid,o,"blob",n.join("/"))}return null}async function El({fs:i,cache:e,gitdir:t}){let r;try{r=await G.resolve({fs:i,gitdir:t,ref:"HEAD"})}catch(a){if(a instanceof be)return[]}const{tree:n}=await Qt({fs:i,cache:e,gitdir:t,oid:r});return n}async function uo({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r="HEAD",filepaths:n=["."],filter:a,cache:s={},ignored:o=!1}){try{T("fs",i),T("gitdir",t),T("ref",r);const c=new Q(i);return await vt({fs:c,cache:s,dir:e,gitdir:t,trees:[Ge({ref:r}),Vt(),At()],map:async function(u,[f,d,h]){if(!f&&!h&&d&&!o&&await Jt.isIgnored({fs:c,dir:e,filepath:u})||!n.some(A=>Qa(u,A)))return null;if(a&&!a(u))return;const[w,_,y]=await Promise.all([f&&f.type(),d&&d.type(),h&&h.type()]),b=[w,_,y].includes("blob");if((w==="tree"||w==="special")&&!b)return;if(w==="commit")return null;if((_==="tree"||_==="special")&&!b)return;if(y==="commit")return null;if((y==="tree"||y==="special")&&!b)return;const v=w==="blob"?await f.oid():void 0,k=y==="blob"?await h.oid():void 0;let S;w!=="blob"&&_==="blob"&&y!=="blob"?S="42":_==="blob"&&(S=await d.oid());const O=[void 0,v,S,k],I=O.map(A=>O.indexOf(A));return I.shift(),[u,...I]}})}catch(c){throw c.caller="git.statusMatrix",c}}async function ho({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,object:n,force:a=!1}){try{T("fs",i),T("gitdir",t),T("ref",r);const s=new Q(i);if(r===void 0)throw new He("ref");r=r.startsWith("refs/tags/")?r:`refs/tags/${r}`;const o=await G.resolve({fs:s,gitdir:t,ref:n||"HEAD"});if(!a&&await G.exists({fs:s,gitdir:t,ref:r}))throw new et("tag",r);await G.writeRef({fs:s,gitdir:t,ref:r,value:o})}catch(s){throw s.caller="git.tag",s}}async function wo({fs:i,dir:e,gitdir:t=M.join(e,".git"),cache:r={},filepath:n,oid:a,mode:s,add:o,remove:c,force:u}){try{T("fs",i),T("gitdir",t),T("filepath",n);const f=new Q(i);if(c)return await Be.acquire({fs:f,gitdir:t,cache:r},async function(h){if(!u){const w=await f.lstat(M.join(e,n));if(w){if(w.isDirectory())throw new gt("directory");return}}h.has({filepath:n})&&h.delete({filepath:n})});let d;if(!a){if(d=await f.lstat(M.join(e,n)),!d)throw new be(`file at "${n}" on disk and "remove" not set`);if(d.isDirectory())throw new gt("directory")}return await Be.acquire({fs:f,gitdir:t,cache:r},async function(h){if(!o&&!h.has({filepath:n}))throw new be(`file at "${n}" in index and "add" not set`);let w;if(a)w={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:s,uid:0,gid:0,size:0};else{w=d;const _=w.isSymbolicLink()?await f.readlink(M.join(e,n)):await f.read(M.join(e,n));a=await Ze({fs:f,gitdir:t,type:"blob",format:"content",object:_})}return h.insert({filepath:n,oid:a,stats:w}),a})}catch(f){throw f.caller="git.updateIndex",f}}function mo(){try{return Hr.version}catch(i){throw i.caller="git.version",i}}async function po({fs:i,dir:e,gitdir:t=M.join(e,".git"),trees:r,map:n,reduce:a,iterate:s,cache:o={}}){try{return T("fs",i),T("gitdir",t),T("trees",r),await vt({fs:new Q(i),cache:o,dir:e,gitdir:t,trees:r,map:n,reduce:a,iterate:s})}catch(c){throw c.caller="git.walk",c}}async function _o({fs:i,dir:e,gitdir:t=M.join(e,".git"),blob:r}){try{return T("fs",i),T("gitdir",t),T("blob",r),await Ze({fs:new Q(i),gitdir:t,type:"blob",object:r,format:"content"})}catch(n){throw n.caller="git.writeBlob",n}}async function go({fs:i,dir:e,gitdir:t=M.join(e,".git"),commit:r}){try{return T("fs",i),T("gitdir",t),T("commit",r),await ao({fs:new Q(i),gitdir:t,commit:r})}catch(n){throw n.caller="git.writeCommit",n}}async function vo({fs:i,dir:e,gitdir:t=M.join(e,".git"),type:r,object:n,format:a="parsed",oid:s,encoding:o=void 0}){try{const c=new Q(i);if(a==="parsed"){switch(r){case"commit":n=ke.from(n).toObject();break;case"tree":n=qe.from(n).toObject();break;case"blob":n=Buffer.from(n,o);break;case"tag":n=Fe.from(n).toObject();break;default:throw new Ue(s||"",r,"blob|commit|tag|tree")}a="content"}return s=await Ze({fs:c,gitdir:t,type:r,object:n,oid:s,format:a}),s}catch(c){throw c.caller="git.writeObject",c}}async function bo({fs:i,dir:e,gitdir:t=M.join(e,".git"),ref:r,value:n,force:a=!1,symbolic:s=!1}){try{T("fs",i),T("gitdir",t),T("ref",r),T("value",n);const o=new Q(i);if(r!==at.clean(r))throw new Qe(r,at.clean(r));if(!a&&await G.exists({fs:o,gitdir:t,ref:r}))throw new et("ref",r);s?await G.writeSymbolicRef({fs:o,gitdir:t,ref:r,value:n}):(n=await G.resolve({fs:o,gitdir:t,ref:n}),await G.writeRef({fs:o,gitdir:t,ref:r,value:n}))}catch(o){throw o.caller="git.writeRef",o}}async function Sl({fs:i,gitdir:e,tag:t}){const r=Fe.from(t).toObject();return await Ze({fs:i,gitdir:e,type:"tag",object:r,format:"content"})}async function yo({fs:i,dir:e,gitdir:t=M.join(e,".git"),tag:r}){try{return T("fs",i),T("gitdir",t),T("tag",r),await Sl({fs:new Q(i),gitdir:t,tag:r})}catch(n){throw n.caller="git.writeTag",n}}async function ko({fs:i,dir:e,gitdir:t=M.join(e,".git"),tree:r}){try{return T("fs",i),T("gitdir",t),T("tree",r),await br({fs:new Q(i),gitdir:t,tree:r})}catch(n){throw n.caller="git.writeTree",n}}var Rl={Errors:za,STAGE:At,TREE:Ge,WORKDIR:Vt,add:Ha,abortMerge:Fa,addNote:Xa,addRemote:Ya,annotatedTag:Va,branch:Ja,checkout:Ji,clone:en,commit:as,getConfig:bs,getConfigAll:ys,setConfig:no,currentBranch:ss,deleteBranch:os,deleteRef:cs,deleteRemote:fs,deleteTag:ls,expandOid:us,expandRef:hs,fastForward:ms,fetch:ps,findMergeBase:_s,findRoot:vs,getRemoteInfo:ks,getRemoteInfo2:Es,hashBlob:Ss,indexPack:Rs,init:rn,isDescendent:$s,isIgnored:As,listBranches:Os,listFiles:js,listNotes:Bs,listRefs:Cs,listRemotes:Ds,listServerRefs:Ps,listTags:Ns,log:Ms,merge:Fs,packObjects:Ls,pull:Hs,push:qs,readBlob:Ws,readCommit:nn,readNote:Xs,readObject:Ks,readTag:Ys,readTree:Vs,remove:Js,removeNote:Qs,renameBranch:eo,resetIndex:ro,updateIndex:wo,resolveRef:io,status:fo,statusMatrix:uo,tag:ho,version:mo,walk:po,writeBlob:_o,writeCommit:go,writeObject:vo,writeRef:bo,writeTag:yo,writeTree:ko,stash:co};const Tl=Object.freeze(Object.defineProperty({__proto__:null,Errors:za,STAGE:At,TREE:Ge,WORKDIR:Vt,abortMerge:Fa,add:Ha,addNote:Xa,addRemote:Ya,annotatedTag:Va,branch:Ja,checkout:Ji,clone:en,commit:as,currentBranch:ss,default:Rl,deleteBranch:os,deleteRef:cs,deleteRemote:fs,deleteTag:ls,expandOid:us,expandRef:hs,fastForward:ms,fetch:ps,findMergeBase:_s,findRoot:vs,getConfig:bs,getConfigAll:ys,getRemoteInfo:ks,getRemoteInfo2:Es,hashBlob:Ss,indexPack:Rs,init:rn,isDescendent:$s,isIgnored:As,listBranches:Os,listFiles:js,listNotes:Bs,listRefs:Cs,listRemotes:Ds,listServerRefs:Ps,listTags:Ns,log:Ms,merge:Fs,packObjects:Ls,pull:Hs,push:qs,readBlob:Ws,readCommit:nn,readNote:Xs,readObject:Ks,readTag:Ys,readTree:Vs,remove:Js,removeNote:Qs,renameBranch:eo,resetIndex:ro,resolveRef:io,setConfig:no,stash:co,status:fo,statusMatrix:uo,tag:ho,updateIndex:wo,version:mo,walk:po,writeBlob:_o,writeCommit:go,writeObject:vo,writeRef:bo,writeTag:yo,writeTree:ko},Symbol.toStringTag,{value:"Module"})),qi=new Xo("tenkai-fs"),Ar="/docs",xo=qi.promises;await en({fs:xo,http:ga,dir:Ar,url:"https://github.com/komatsuben/tenkai",corsProxy:"https://cors.isomorphic-git.org",singleBranch:!0,depth:1});async function Ll(){try{await xo.mkdir(Ar)}catch{}return await rn({fs:qi,dir:Ar}),{fs:qi,dir:Ar,git:Tl,http:ga}}export{Ll as initRepo};
